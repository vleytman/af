{"version":3,"file":"af-gsap.esm.js","sources":["../src/af-core.js","../src/af-gsap.js"],"sourcesContent":["let Config = {\n  prefix: 'af-',\n  breakpoints: {\n    sm: '(max-width: 640px)',\n    md: '(min-width: 641px) and (max-width: 768px)',\n    lg: '(min-width: 769px) and (max-width: 1024px)',\n    xl: '(min-width: 1025px) and (max-width: 1280px)',\n    xxl: '(min-width: 1281px)',\n  },\n  engine: 'gsap',\n  debug: true,\n}\n\nlet AnimationEngine = {}\n\nconst debug = {\n  log: (...args) => { AF.Config.debug && console.log('[AF]', ...args) },\n  warn: (...args) => { AF.Config.debug && console.warn('[AF]', ...args) },\n  error: (...args) => { AF.Config.debug && console.error('[AF]', ...args) },\n}\n\nconst utils = {\n\n  deepMergeObjects (target, source) {\n    if (Array.isArray(target) && Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(target)) {\n      return source\n    } else if (typeof target === 'object' && typeof source === 'object' && target !== null && source !== null) {\n      const output = { ...target }\n      Object.keys(source).forEach(key => {\n        output[key] = this.deepMergeObjects(target[key], source[key])\n      })\n      return output\n    } else {\n      return source\n    }\n  },\n\n  mergeConfig (config) {\n    AF.Config = this.deepMergeObjects(AF.Config, config)\n    AF.Config.breakpoints = config.breakpoints ?? AF.Config.breakpoints\n  },\n\n  hasElementsWithAttributes (elements, attributes) {\n    return elements.some(element => attributes.some(attr => Object.keys(element.attributes).includes(attr)))\n  },\n\n  generateRandomName () {\n    return Math.random().toString(36).substring(2, 10)\n  },\n\n  kebabCase (str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n  },\n\n  debounce (func, wait) {\n    let timeout\n    return function executedFunction (...args) {\n      const later = () => {\n        clearTimeout(timeout)\n        func(...args)\n      }\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n    }\n  },\n\n  getBreakpointMaxWidth (query) {\n    const maxWidthMatch = query.match(/\\(max-width:\\s*(\\d+)px\\)/)\n    const minWidthMatch = query.match(/\\(min-width:\\s*(\\d+)px\\)/)\n    if (maxWidthMatch) {\n      return parseInt(maxWidthMatch[1])\n    } else if (minWidthMatch) {\n      return Infinity\n    }\n    return 0\n  },\n\n}\n\nconst Parser = {\n\n  parsers: {\n    timeline: { flow: ['disallowEmpty', 'parseTimelineValue'], responsive: true },\n    from: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    to: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    keyframes: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues', 'parseKeyframesValue'], responsive: true },\n    options: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    target: { flow: ['parseSelectorValue'], responsive: false },\n    on: { flow: ['disallowEmpty', 'parseOnValue'], responsive: true },\n    action: { flow: ['disallowEmpty', 'parseActionValue'], responsive: true },\n    scroll: { flow: ['parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    splittext: { flow: ['parseSplitTextValue'], responsive: true },\n    pause: { flow: ['parseEmptyValue'], responsive: true },\n  },\n\n  parseElements () {\n    const elements = Array.from(new Set([...this.getAnimatableElements(), ...this.getAnimatableElementsByPreset()]))\n    if (!elements) return\n    return this.processAttributes(elements)\n  },\n\n  getAnimatableElementsByPreset () {\n    return Object.entries(AF.Config.presets).flatMap(([presetName, preset]) => {\n      const className = `${AF.Config.prefix}${utils.kebabCase(presetName)}`\n      return [...document.getElementsByClassName(className)].map(element => {\n        element.setAttribute(`${AF.Config.prefix}preset`, presetName)\n        return element\n      })\n    })\n  },\n\n  processAttributes (elements) {\n    if (!elements) return\n    let parsedElements = []\n    elements.forEach(element => {\n      try {\n        parsedElements.push(this.parseSingleElement(element))\n      } catch {\n        debug.error(`Can't parse element:`, element)\n      }\n    })\n    parsedElements = this.propagateBreakpoints(parsedElements)\n    return parsedElements\n  },\n\n  parseSingleElement (element) {\n    const attributes = this.parseElementAttributes(element)\n    const targets = this.getTargets({ element, attributes })\n    return { element, attributes, targets }\n  },\n\n  propagateBreakpoints (data) {\n    const configBreakpoints = Object.keys(AF.Config.breakpoints).sort((a, b) => {\n      const aWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[a])\n      const bWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[b])\n      return bWidth - aWidth\n    })\n    return data.map(element => {\n      for (const [attrKey, attrValue] of Object.entries(element.attributes)) {\n        if (this.parsers[attrKey] && this.parsers[attrKey].responsive) {\n          const hasDefault = 'default' in attrValue\n          const presentBreakpoints = Object.keys(attrValue).filter(bp => bp !== 'default' && bp in AF.Config.breakpoints)\n          let propagatedValues = {}\n          if (hasDefault) {\n            propagatedValues = utils.deepMergeObjects({}, attrValue.default)\n          }\n          configBreakpoints.forEach(bp => {\n            if (bp in attrValue) {\n              propagatedValues = utils.deepMergeObjects(propagatedValues, attrValue[bp])\n            }\n            element.attributes[attrKey][bp] = utils.deepMergeObjects({}, propagatedValues)\n          })\n          if (hasDefault) {\n            delete element.attributes[attrKey].default\n          }\n        }\n      }\n      return element\n    })\n  },\n\n  getTargets (elementData) {\n    if (elementData.attributes?.target === '&' || !elementData.attributes?.target) return [elementData.element]\n    const targetSelector = elementData.attributes.target.trim()\n    const subSelector = targetSelector.slice(1).trim()\n    if (targetSelector.startsWith('&')) {\n      const matchedElements = this.getMatchedElements(elementData.element, subSelector)\n      return matchedElements.length ? matchedElements : [elementData.element]\n    }\n    return document.querySelectorAll(targetSelector)\n  },\n\n  getMatchedElements (element, subSelector) {\n    if (subSelector.match(/^([.#\\[])/) && element.matches(subSelector)) return [element]\n    if (subSelector.startsWith('>')) return [...element.children].filter(child => child.matches(subSelector.slice(1).trim()))\n    return [...element.querySelectorAll(subSelector)]\n  },\n\n  getAnimatableElements () {\n    const elements = Array.from(document.querySelectorAll('*'))\n    return elements.filter(element =>\n      Array.from(element.attributes).some(attr => attr.name.startsWith(AF.Config.prefix))\n    )\n  },\n\n  parseElementAttributes (element) {\n    let parsedAttributes = {}\n    let presetName = null\n    Array.from(element.attributes).forEach(attr => {\n      if (attr.name === `${AF.Config.prefix}preset`) {\n        presetName = attr.value.trim()\n        return\n      }\n      if (attr.name.startsWith(AF.Config.prefix)) {\n        const components = this.extractAttributeComponents(attr.name)\n        if (!components) return\n        const { type, breakpoint } = components\n        if (!this.parsers[type]) {\n          debug.warn(`Unknown attribute: ${attr.name}`)\n          return\n        }\n        let parsedData = this.runParsers(element, type, attr.value)\n        if (parsedData) {\n          parsedAttributes[type] = parsedAttributes[type] ?? {}\n          parsedAttributes[type][breakpoint] = parsedData\n          parsedAttributes[type] = this.checkIfResponsiveAttribute(parsedAttributes[type], type)\n        } else {\n          debug.warn(`Error parsing \"${type}\" attribute value: ${attr.value}`)\n        }\n      }\n    })\n    if (presetName) {\n      const presetAttributes = this.parsePresetAttributes(presetName, element)\n      this.deepMergeAttributes(parsedAttributes, presetAttributes)\n    }\n    return parsedAttributes\n  },\n\n  extractAttributeComponents (attrName) {\n    const attrUnprefixedName = attrName.slice(AF.Config.prefix.length)\n    const match = attrUnprefixedName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/)\n    if (match[2] && !AF.Config.breakpoints[match[2]]) {\n      debug.warn(`Invalid breakpoint: ${match[2]}`)\n      return null\n    }\n    return match ? { type: match[1], breakpoint: match[2] || 'default' } : null\n  },\n\n  runParsers (element, type, value) {\n    try {\n      let parsedData = {}\n      let lastValue = null\n      for (const parser of this.parsers[type].flow) {\n        parsedData = lastValue ? this[parser](lastValue, element) : this[parser](value, element)\n        lastValue = parsedData\n      }\n      return parsedData\n    } catch (error) {\n      return null\n    }\n  },\n\n  disallowEmpty (value, element) {\n    if (value === '') throw new Error(`Empty value for attribute is not allowed`)\n    return value\n  },\n\n  checkIfResponsiveAttribute (data, type) {\n    return !Parser.parsers[type].responsive ? data[Object.keys(data)[0]] : data\n  },\n\n  parsePresetAttributes (presetName, element) {\n    const preset = AF.Config.presets[presetName]\n    if (!preset) {\n      debug.warn(`Preset \"${presetName}\" not found`)\n      return {}\n    }\n    return Object.entries(preset).reduce((presetAttrs, [attrName, attrValue]) => {\n      if (attrName === 'selector') return presetAttrs\n      const [, type, breakpoint = 'default'] = attrName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/) || []\n      if (!type || !this.parsers[type]) {\n        debug.warn(`Invalid or unknown preset attribute: \"${attrName}\"`)\n        return presetAttrs\n      }\n      if (breakpoint !== 'default' && !AF.Config.breakpoints[breakpoint]) {\n        debug.warn(`Invalid breakpoint \"${breakpoint}\" in preset \"${presetName}\" for type \"${type}\"`)\n        return presetAttrs\n      }\n      let parsedData = this.runParsers(element, type, attrValue)\n      if (parsedData) {\n        presetAttrs[type] = { ...presetAttrs[type], [breakpoint]: parsedData }\n      } else {\n        debug.warn(`Error parsing \"${type}\" attribute value: ${attrValue}`)\n      }\n      return presetAttrs\n    }, {})\n  },\n\n  parseObjectAttribute (value, element) {\n    if (typeof value === 'object') return value // Already parsed\n    value = this.resolveVariables(value, element) // Resolve variables\n    value = this.escapeCommas(value) // Escape commas inside brackets\n    value = value.replace(/'/g, '\"') // Single quotes => double quotes\n      .replace(/\\s+/g, ' ').trim() // Normalize whitespace\n      .replace(/(^|[,{]\\s*)([^\\s,\"'{}[\\]:]+)(\\s*:)/g, '$1\"$2\"$3') // Quote keys (including at the start of the string)\n      .replace(/(:\\s*)([^,{}\\[\\]\\s][^,{}\\[\\]]*)(?=[,}\\]]|$)/g, (match, p1, p2) => { // Quote values, skipping arrays and objects\n        const trimmedValue = p2.trim()\n        if (trimmedValue.startsWith('[') || trimmedValue.startsWith('{')) return `${p1}${trimmedValue}` // Skip arrays and objects\n        if (/^-?\\d+(\\.\\d+)?$/.test(trimmedValue) || /^(true|false|null)$/i.test(trimmedValue)) return `${p1}${trimmedValue}` // Do not quote numbers, booleans, null\n        if (!/^\".*\"$/.test(trimmedValue)) return `${p1}\"${trimmedValue}\"` // Quote if not already quoted\n        return match\n      })\n      .replace(/__COMMA__/g, ',')\n\n    return value\n  },\n\n  escapeCommas (str) {\n    let result = ''\n    let depth = 0\n    let inQuote = false\n    let quoteChar = ''\n    const brackets = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    }\n    const stack = []\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i]\n\n      if (inQuote) {\n        result += c\n        if (c === quoteChar) {\n          inQuote = false\n        }\n      } else if (c === '\"' || c === '\\'') {\n        inQuote = true\n        quoteChar = c\n        result += c\n      } else if (brackets[c]) {\n        stack.push(brackets[c])\n        depth++\n        result += c\n      } else if (stack.length > 0 && c === stack[stack.length - 1]) {\n        stack.pop()\n        depth--\n        result += c\n      } else if (c === ',' && depth > 0) {\n        result += '__COMMA__'\n      } else {\n        result += c\n      }\n    }\n    return result\n  },\n\n  deepMergeAttributes (target, source) {\n    for (const [type, typeData] of Object.entries(source)) {\n      if (!target[type]) {\n        target[type] = utils.deepMergeObjects({}, typeData)\n        continue\n      }\n      for (const [breakpoint, value] of Object.entries(typeData)) {\n        if (!target[type][breakpoint]) {\n          target[type][breakpoint] = value\n        } else {\n          target[type][breakpoint] = utils.deepMergeObjects(target[type][breakpoint], value)\n        }\n      }\n    }\n  },\n\n  resolveVariables (str, element) {\n    let resolvedStr = str.replace(/var\\((--[^)]+)\\)/g, (match, varName) => {\n      const computedValue = getComputedStyle(element).getPropertyValue(varName).trim()\n      return computedValue || 'undefined'\n    })\n    resolvedStr = resolvedStr.replace(/\\${([^}]+)}/g, (_, p1) => this.evaluateExpression(p1.trim(), this.getElementContext(element)))\n    return resolvedStr\n  },\n\n  evaluateExpression: (() => {\n    const cache = new Map()\n    return (expression, context) => {\n      if (!cache.has(expression)) cache.set(expression, new Function('\"use strict\";return (' + expression + ')'))\n      try {\n        return cache.get(expression).call(context)\n      } catch (error) {\n        debug.error(`Error evaluating expression: ${expression}`, error)\n        return undefined\n      }\n    }\n  })(),\n\n  getElementContext (element) {\n    return {\n      $element: element,\n      window,\n      document,\n    }\n  },\n\n  parseJsonToObjectOrArray (value, element) {\n    if (typeof value === 'object') return value\n    try {\n      return JSON.parse(`{${value}}`)\n    } catch (error1) {\n      try {\n        return JSON.parse(`[${value}]`)\n      } catch (error2) {\n        debug.error('Error parsing attribute value:', value, error2)\n        return null\n      }\n    }\n  },\n\n  normalizeAttributeValues (data) {\n    if (Array.isArray(data)) {\n      return data.map(value => this.normalizeAttributeValues(value))\n    }\n    if (data !== null && typeof data === 'object') {\n      return Object.fromEntries(\n        Object.entries(data).map(([key, value]) => [key, this.normalizeAttributeValues(value)])\n      )\n    }\n    return this.normalizeValue(data)\n  },\n\n  normalizeValue (value) {\n    if (typeof value === 'number') return value\n    if (typeof value !== 'string') return value\n    const trimmed = value.trim()\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) return Number(trimmed)\n    if (/^(true|false)$/i.test(trimmed)) return trimmed.toLowerCase() === 'true'\n    return value\n  },\n\n  parseTimelineValue (value) {\n    const parts = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (parts.length > 3) throw new Error(`Invalid timeline value: ${value}. Expected format: name[, position][, properties]`)\n    return parts.length === 1 ? { name: String(parts[0]), position: null } : parts.length === 2 ? { name: parts[0], position: this.normalizeValue(parts[1]) } : {\n      name: parts[0],\n      position: this.normalizeValue(parts[1]),\n      options: this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(parts[2], null), null))[0]\n    }\n  },\n\n  parseSelectorValue (value, element) {\n    return value.trim()\n  },\n\n  parseOnValue (value, element) {\n    const parts = value.split(',').map(s => s.trim())\n    return { events: parts }\n  },\n\n  parseActionValue (value, element) {\n    const [action, target, ...argParts] = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (!target || !action) {\n      throw new Error(`Invalid action format: \"${value}\", needs at least target and action.`)\n    }\n    const argStr = argParts.join(',').trim()\n    const args = argStr ? argStr.startsWith('{') && argStr.endsWith('}')\n      ? this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(argStr, element), element))\n      : this.normalizeValue(argStr) : {}\n    return {\n      action, target,\n      arguments: args\n    }\n  },\n\n  parseKeyframesValue (value, element) {\n    return value\n  },\n\n  parseSplitTextValue (value, element) {\n    if (typeof value === 'object') return value\n    if (value.includes(':')) {\n      value = this.parseObjectAttribute(value, element)\n      value = this.parseJsonToObjectOrArray(value, element)\n      value = this.normalizeAttributeValues(value)\n      return value\n    }\n    const types = value.split(',').map(s => s.trim()).filter(s => s.length > 0)\n    return { type: types.join(', ') }\n  },\n\n  parseEmptyValue (value, element) {\n    return true\n  },\n\n  getTimelines (elements) {\n    const timelines = {}\n    const processBreakpoint = (item, bp) => {\n      const { attributes, element, targets } = item\n      const timelineName = attributes.timeline?.[bp]?.name ?? attributes.timeline?.default?.name ?? (element.id.length ? element.id : null) ?? utils.generateRandomName()\n      timelines[bp] ??= {}\n      timelines[bp][timelineName] ??= { animations: [], options: {} }\n      const bpAttrs = Object.fromEntries(\n        Object.entries(attributes)\n          .filter(([, value]) => value[bp] || (value.default && bp === 'default'))\n          .map(([key, value]) => [key, value[bp] ?? value.default])\n      )\n      timelines[bp][timelineName].animations.push({ element, attributes: bpAttrs, targets })\n      if (Object.keys(timelines[bp][timelineName].options).length === 0) {\n        timelines[bp][timelineName].options = this.getTimelineOptions(attributes.timeline)\n      }\n    }\n    elements.forEach(item => {\n      const usedBreakpoints = new Set(Object.values(item.attributes).flatMap(attr => Object.keys(attr)))\n      if (usedBreakpoints.has('default')) {\n        usedBreakpoints.delete('default')\n        processBreakpoint(item, 'default')\n      }\n      usedBreakpoints.forEach(bp => processBreakpoint(item, bp))\n    })\n    return Object.fromEntries(Object.entries(timelines).filter(([key]) => isNaN(key)))\n  },\n\n  getTimelineOptions (timeline) {\n    if (!timeline) return {}\n    for (const key in timeline) {\n      if (timeline[key] && timeline[key].options) return timeline[key].options\n    }\n    return {}\n  },\n\n}\n\nconst AF = {\n\n  debug,\n  utils,\n  Parser,\n  Config,\n  engines: {},\n\n  registerEngine (name, engineClass, plugins) {\n    AF.engines[name] = {}\n    AF.engines[name].engineClass = engineClass\n    AF.engines[name].plugins = plugins\n    console.debug('AF Engine registered', AF.engines[name])\n  },\n\n  init (config = null) {\n    if (!AF.engines) return\n    if (config) AF.utils.mergeConfig(config)\n    const elements = Parser.parseElements()\n    const timelines = Parser.getTimelines(elements)\n    const EngineClass = AF.engines[Config.engine].engineClass\n    if (!EngineClass) {\n      this.debug.error(`Incorrect animation engine: ${AF.Config.engine}`)\n      return\n    }\n    const animationEngine = new EngineClass(elements, timelines)\n    if (animationEngine.init && typeof animationEngine.init === 'function') {\n      animationEngine.init(AF.engines[Config.engine], AF.Config)\n    }\n  },\n\n}\n\nconsole.debug('AF load')\nexport default AF","import AF from './af-core.js'\n\nclass AFEngineGSAP {\n\n  gsapTimelines = []\n  elements = []\n  timelines = {}\n  matchMedia = null\n  gsap = null\n  plugins = null\n\n  defaults = {\n    scrollTrigger: {\n      start: 'top 90%',\n      end: 'bottom 10%',\n      toggleActions: 'play reverse play reverse',\n      scrub: false,\n      invalidateOnRefresh: true\n    },\n    scrollSmoother: {\n      enabled: false,\n      options: {\n        smooth: 1,\n        effects: true,\n        smoothTouch: 0.1,\n      }\n    },\n    allDefaults: {\n      force3D: true,\n      lazy: false,\n    },\n    actions: {\n      play: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          timeline.play()\n        }\n      },\n      pause: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.pause()\n      },\n      restart: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.restart()\n      },\n      reverse: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.reverse()\n      },\n      toggle: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          if (!timeline.reversed()) {\n            timeline.reverse()\n          } else {\n            timeline.play()\n          }\n        }\n      },\n    },\n  }\n\n  constructor (elements, timelines) {\n    this.elements = elements\n    this.timelines = timelines\n  }\n\n  init (settings, config) {\n    AF.Config = config\n    console.debug('AF Engine GSAP init', AF.Config, config)\n    if (!settings?.plugins?.gsap && !window.gsap) {\n      AF.debug.error('GSAP core not found')\n      return\n    }\n    console.debug('AF Engine GSAP init', AF.Config)\n    this.gsap = settings?.plugins?.gsap || window.gsap\n    this.plugins = settings?.plugins || {}\n    this.loadRequiredPlugins(this.elements)\n    this.initScrollSmoother()\n    this.matchMedia = this.gsap.matchMedia()\n    this.animate()\n  }\n\n  loadRequiredPlugins (elements) {\n    if (AF.utils.hasElementsWithAttributes(elements, ['scroll'])) {\n      this.plugins.ScrollTrigger = this.plugins?.ScrollTrigger || ScrollTrigger\n      this.gsap.registerPlugin(this.plugins.ScrollTrigger)\n    }\n    if (AF.utils.hasElementsWithAttributes(elements, ['splittext'])) {\n      this.plugins.SplitText = this.plugins?.SplitText || SplitText\n      this.gsap.registerPlugin(this.plugins.SplitText)\n    }\n  }\n\n  animate () {\n    if (!this.timelines) return\n    this.cleanup()\n    for (const [bp, timelines] of Object.entries(this.timelines)) {\n      this.matchMedia.add(AF.Config.breakpoints[bp], (context) => {\n        for (let [tlName, tl] of Object.entries(timelines)) {\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: bp, timeline: tlInstance })\n          for (const animation of tl.animations) {\n            const animationInstance = this.createSingleAnimation(animation, bp)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          }\n        }\n        this.setupEventActions(bp, context)\n      })\n    }\n    this.handleResize()\n    this.handlePageShow()\n    this.handleLoad()\n    this.refresh()\n  }\n\n  setupEventActions (breakpoint, context) {\n    this.elements.forEach(elementData => {\n      const { element, attributes, targets } = elementData\n      if (attributes?.on?.[breakpoint] && attributes?.action?.[breakpoint]) {\n        const events = attributes.on[breakpoint].events\n        const actionData = attributes.action[breakpoint]\n        events.forEach(eventName => {\n          targets.forEach(target => {\n            const handler = (event) => {\n              this.handleAction(actionData.action, actionData.target, actionData.arguments, event, breakpoint)\n            }\n            context.add(() => {\n              target.addEventListener(eventName, handler)\n              return () => {\n                target.removeEventListener(eventName, handler)\n              }\n            })\n          })\n        })\n      }\n    })\n  }\n\n  handleAction (actionName, actionTarget, actionArgs, event, breakpoint) {\n    console.debug('AFactionsHandle', this.defaults.actions, AF.Config.actions)\n    if (typeof this.defaults.actions[actionName] === 'function') {\n      this.defaults.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else if (typeof AF.Config.actions[actionName] === 'function') {\n      AF.Config.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else {\n      AF.debug.warn(`Action \"${actionName}\" not found.`)\n    }\n  }\n\n  getTimelineByName (name, breakpoint) {\n    const timelineEntry = this.gsapTimelines.find(tl => tl.name === name && tl.breakpoint === breakpoint)\n    return timelineEntry ? timelineEntry.timeline : null\n  }\n\n  refresh () {\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.update()\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.getAll().forEach(trigger => trigger.refresh())\n  }\n\n  handleLoad () {\n    window.addEventListener('load', () => this.refresh())\n  }\n\n  handleResize () {\n    window.addEventListener('resize', AF.utils.debounce(() => this.refresh(), 200), { passive: true })\n  }\n\n  handlePageShow () {\n    window.addEventListener('pageshow', (event) => event.persisted && this.refresh() && this.animate())\n  }\n\n  getConfig (key) {\n    return AF.Config[key] ?? this.defaults[key] ?? null\n  }\n\n  getScrollTrigger (attributes, element) {\n    if (!attributes.scroll) return {}\n    let scrollAttributes = Object.keys(attributes.scroll).length === 0 ? this.getConfig('scrollTrigger') : attributes.scroll\n    return { scrollTrigger: { trigger: element, ...scrollAttributes } }\n  }\n\n  getSplitText (attributes, targets) {\n    if (!attributes.splittext) return targets\n    const splitTextOptions = attributes.splittext\n    const split = new this.plugins.SplitText(targets, splitTextOptions)\n    const typeString = splitTextOptions.type || ''\n    const types = typeString.split(',').map(s => s.trim())\n    let animationTargets = []\n    if (types.includes('chars')) animationTargets = animationTargets.concat(split.chars)\n    if (types.includes('words')) animationTargets = animationTargets.concat(split.words)\n    if (types.includes('lines')) animationTargets = animationTargets.concat(split.lines)\n    if (animationTargets.length === 0) animationTargets = targets\n    return animationTargets\n  }\n\n  prepareTimeline (tl) {\n    let scrollTrigger = null\n    let pause = false\n    tl.animations.forEach(animation => {\n      if (animation.attributes?.scroll) {\n        scrollTrigger = !scrollTrigger ? { scroll: animation.attributes.scroll ?? scrollTrigger, scrollElement: animation.element ?? scrollElement } : scrollTrigger\n        delete animation.attributes.scroll\n      }\n      if (animation.attributes?.pause) {\n        pause = !pause ? { pause: true } : pause\n        delete animation.attributes.pause\n      }\n    })\n    return { ...tl, ...scrollTrigger, ...pause }\n  }\n\n  createSingleAnimation (animation, breakpoint) {\n    const { element, attributes, targets } = animation\n    let options = { ...this.getScrollTrigger(attributes, element), ...this.getConfig('allDefaults') }\n    let animationTargets = this.getSplitText(attributes, targets)\n    if (attributes.keyframes) return this.gsap.to(animationTargets, { keyframes: attributes.keyframes, ...attributes?.options, ...options })\n    if (attributes.from && !attributes.to) return this.gsap.from(animationTargets, { ...attributes.from, ...attributes?.options, ...options })\n    if (attributes.to && !attributes.from) return this.gsap.to(animationTargets, { ...attributes.to, ...attributes?.options, ...options })\n    if (attributes.from && attributes.to) return this.gsap.fromTo(animationTargets, attributes.from, { ...attributes.to, ...attributes?.options, ...options })\n  }\n\n  initScrollSmoother () {\n    if (!this.getConfig('scrollSmoother')?.enabled) return\n    this.plugins.ScrollSmoother = this.plugins?.ScrollSmoother || ScrollSmoother\n    this.gsap.registerPlugin(this.plugins.ScrollSmoother)\n    const content = document.querySelector('#smooth-content')\n    if (!content) {\n      AF.debug.error('ScrollSmoother: No #smooth-content found')\n      return\n    }\n    this.plugins.ScrollSmoother.create({\n      ...this.getConfig('scrollSmoother').options,\n      wrapper: '#smooth-wrapper',\n      content: '#smooth-content',\n    })\n  }\n\n  cleanup () {\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.killAll()\n    if (this.gsapTimelines) {\n      this.gsapTimelines.forEach(({ timeline }) => timeline.kill())\n      this.gsapTimelines = []\n    }\n  }\n\n}\n\nconsole.debug('AF Engine GSAP loaded')\nexport default AFEngineGSAP"],"names":["Config","prefix","breakpoints","sm","md","lg","xl","xxl","engine","debug","log","args","AF","console","warn","error","utils","deepMergeObjects","target","source","Array","isArray","slice","output","Object","keys","forEach","key","this","mergeConfig","config","hasElementsWithAttributes","elements","attributes","some","element","attr","includes","generateRandomName","Math","random","toString","substring","kebabCase","str","replace","toLowerCase","debounce","func","wait","timeout","clearTimeout","setTimeout","getBreakpointMaxWidth","query","maxWidthMatch","match","minWidthMatch","parseInt","Infinity","Parser","parsers","timeline","flow","responsive","from","to","keyframes","options","on","action","scroll","splittext","pause","parseElements","Set","getAnimatableElements","getAnimatableElementsByPreset","processAttributes","entries","presets","flatMap","presetName","preset","className","document","getElementsByClassName","map","setAttribute","parsedElements","push","parseSingleElement","propagateBreakpoints","parseElementAttributes","targets","getTargets","data","configBreakpoints","sort","a","b","aWidth","attrKey","attrValue","hasDefault","filter","bp","propagatedValues","default","elementData","targetSelector","trim","subSelector","startsWith","matchedElements","getMatchedElements","length","querySelectorAll","matches","children","child","name","parsedAttributes","components","extractAttributeComponents","type","breakpoint","parsedData","runParsers","value","checkIfResponsiveAttribute","presetAttributes","parsePresetAttributes","deepMergeAttributes","attrName","lastValue","parser","disallowEmpty","Error","reduce","presetAttrs","parseObjectAttribute","resolveVariables","escapeCommas","p1","p2","trimmedValue","test","result","depth","inQuote","quoteChar","brackets","stack","i","c","pop","typeData","resolvedStr","varName","getComputedStyle","getPropertyValue","_","evaluateExpression","getElementContext","cache","Map","expression","context","has","set","Function","get","call","$element","window","parseJsonToObjectOrArray","JSON","parse","error1","error2","normalizeAttributeValues","fromEntries","normalizeValue","trimmed","Number","parseTimelineValue","parts","split","s","String","position","parseSelectorValue","parseOnValue","events","parseActionValue","argParts","argStr","join","arguments","endsWith","parseKeyframesValue","parseSplitTextValue","parseEmptyValue","getTimelines","timelines","processBreakpoint","item","timelineName","id","animations","bpAttrs","getTimelineOptions","usedBreakpoints","values","delete","isNaN","engines","registerEngine","engineClass","plugins","init","EngineClass","animationEngine","AFEngineGSAP","gsapTimelines","matchMedia","gsap","defaults","scrollTrigger","start","end","toggleActions","scrub","invalidateOnRefresh","scrollSmoother","enabled","smooth","effects","smoothTouch","allDefaults","force3D","lazy","actions","play","event","getTimelineByName","restart","reverse","toggle","reversed","constructor","settings","loadRequiredPlugins","initScrollSmoother","animate","ScrollTrigger","registerPlugin","SplitText","cleanup","add","tlName","tl","prepareTimeline","getScrollTrigger","scrollElement","tlInstance","animation","animationInstance","createSingleAnimation","setupEventActions","handleResize","handlePageShow","handleLoad","refresh","actionData","eventName","handler","handleAction","addEventListener","removeEventListener","actionName","actionTarget","actionArgs","timelineEntry","find","update","getAll","trigger","passive","persisted","getConfig","getSplitText","splitTextOptions","types","animationTargets","concat","chars","words","lines","fromTo","ScrollSmoother","querySelector","create","wrapper","content","killAll","kill"],"mappings":"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"}