{"version":3,"file":"af-gsap.umd.js","sources":["../src/af-core.js","../src/af-gsap.js"],"sourcesContent":["let Config = {\n  prefix: 'af-',\n  breakpoints: {\n    sm: '(max-width: 640px)',\n    md: '(min-width: 641px) and (max-width: 768px)',\n    lg: '(min-width: 769px) and (max-width: 1024px)',\n    xl: '(min-width: 1025px) and (max-width: 1280px)',\n    xxl: '(min-width: 1281px)',\n  },\n  engine: 'gsap',\n  debug: true,\n}\n\nlet AnimationEngine = {}\n\nconst debug = {\n  log: (...args) => { AF.Config.debug && console.log('[AF]', ...args) },\n  warn: (...args) => { AF.Config.debug && console.warn('[AF]', ...args) },\n  error: (...args) => { AF.Config.debug && console.error('[AF]', ...args) },\n}\n\nconst utils = {\n\n  hasAnimationAttributes (element) {\n    return Array.from(element.attributes).some(attr => attr.name.startsWith(AF.Config.prefix))\n  },\n\n  deepMergeObjects (target, source) {\n    if (Array.isArray(target) && Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(target)) {\n      return source\n    } else if (typeof target === 'object' && typeof source === 'object' && target !== null && source !== null) {\n      const output = { ...target }\n      Object.keys(source).forEach(key => {\n        output[key] = this.deepMergeObjects(target[key], source[key])\n      })\n      return output\n    } else {\n      return source\n    }\n  },\n\n  mergeConfig (config) {\n    AF.Config = this.deepMergeObjects(AF.Config, config)\n    AF.Config.breakpoints = config.breakpoints ?? AF.Config.breakpoints\n  },\n\n  hasElementsWithAttributes (elements, attributes) {\n    return elements.some(element => attributes.some(attr => Object.keys(element.attributes).includes(attr)))\n  },\n\n  generateRandomName () {\n    return Math.random().toString(36).substring(2, 10)\n  },\n\n  kebabCase (str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n  },\n\n  debounce (func, wait) {\n    let timeout\n    return function executedFunction (...args) {\n      const later = () => {\n        clearTimeout(timeout)\n        func(...args)\n      }\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n    }\n  },\n\n  getBreakpointMaxWidth (query) {\n    const maxWidthMatch = query.match(/\\(max-width:\\s*(\\d+)px\\)/)\n    const minWidthMatch = query.match(/\\(min-width:\\s*(\\d+)px\\)/)\n    if (maxWidthMatch) {\n      return parseInt(maxWidthMatch[1])\n    } else if (minWidthMatch) {\n      return Infinity\n    }\n    return 0\n  },\n\n}\n\nconst Parser = {\n\n  parsers: {\n    timeline: { flow: ['disallowEmpty', 'parseTimelineValue'], responsive: true },\n    from: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    to: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    keyframes: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues', 'parseKeyframesValue'], responsive: true },\n    options: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    target: { flow: ['parseSelectorValue'], responsive: false },\n    on: { flow: ['disallowEmpty', 'parseOnValue'], responsive: true },\n    action: { flow: ['disallowEmpty', 'parseActionValue'], responsive: true },\n    scroll: { flow: ['parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    splittext: { flow: ['parseSplitTextValue'], responsive: true },\n    pause: { flow: ['parseEmptyValue'], responsive: true },\n  },\n\n  parseElements () {\n    const elements = Array.from(new Set([...this.getAnimatableElements(), ...this.getAnimatableElementsByPreset()]))\n    if (!elements) return\n    return this.processAttributes(elements)\n  },\n\n  getAnimatableElementsByPreset () {\n    if (!AF.Config.presets) return []\n    return Object.entries(AF.Config.presets).flatMap(([presetName, preset]) => {\n      const className = `${AF.Config.prefix}${utils.kebabCase(presetName)}`\n      return [...document.getElementsByClassName(className)].map(element => {\n        element.setAttribute(`${AF.Config.prefix}preset`, presetName)\n        return element\n      })\n    })\n  },\n\n  processAttributes (elements) {\n    if (!elements) return\n    let parsedElements = []\n    elements.forEach(element => {\n      try {\n        parsedElements.push(this.parseSingleElement(element))\n      } catch {\n        debug.error(`Can't parse element:`, element)\n        return parsedElements\n      }\n    })\n    parsedElements = this.propagateBreakpoints(parsedElements)\n    return parsedElements\n  },\n\n  parseSingleElement (element) {\n    const attributes = this.parseElementAttributes(element)\n    const targets = this.getTargets({ element, attributes })\n    return { element, attributes, targets }\n  },\n\n  propagateBreakpoints (data) {\n    const configBreakpoints = Object.keys(AF.Config.breakpoints).sort((a, b) => {\n      const aWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[a])\n      const bWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[b])\n      return bWidth - aWidth\n    })\n    return data.map(element => {\n      for (const [attrKey, attrValue] of Object.entries(element.attributes)) {\n        if (this.parsers[attrKey] && this.parsers[attrKey].responsive) {\n          const hasDefault = 'default' in attrValue\n          const presentBreakpoints = Object.keys(attrValue).filter(bp => bp !== 'default' && bp in AF.Config.breakpoints)\n          let propagatedValues = {}\n          if (hasDefault) {\n            propagatedValues = utils.deepMergeObjects({}, attrValue.default)\n          }\n          configBreakpoints.forEach(bp => {\n            if (bp in attrValue) {\n              propagatedValues = utils.deepMergeObjects(propagatedValues, attrValue[bp])\n            }\n            element.attributes[attrKey][bp] = utils.deepMergeObjects({}, propagatedValues)\n          })\n          if (hasDefault) {\n            delete element.attributes[attrKey].default\n          }\n        }\n      }\n      return element\n    })\n  },\n\n  getTargets (elementData) {\n    if (elementData.attributes?.target === '&' || !elementData.attributes?.target) return [elementData.element]\n    const targetSelector = elementData.attributes.target.trim()\n    const subSelector = targetSelector.slice(1).trim()\n    if (targetSelector.startsWith('&')) {\n      const matchedElements = this.getMatchedElements(elementData.element, subSelector)\n      return matchedElements.length ? matchedElements : [elementData.element]\n    }\n    return document.querySelectorAll(targetSelector)\n  },\n\n  getMatchedElements (element, subSelector) {\n    if (subSelector.match(/^([.#\\[])/) && element.matches(subSelector)) return [element]\n    if (subSelector.startsWith('>')) return [...element.children].filter(child => child.matches(subSelector.slice(1).trim()))\n    return [...element.querySelectorAll(subSelector)]\n  },\n\n  getAnimatableElements () {\n    const elements = Array.from(document.querySelectorAll('*'))\n    return elements.filter(element =>\n      Array.from(element.attributes).some(attr => attr.name.startsWith(AF.Config.prefix))\n    )\n  },\n\n  parseElementAttributes (element) {\n    let parsedAttributes = {}\n    let presetName = null\n    Array.from(element.attributes).forEach(attr => {\n      if (attr.name === `${AF.Config.prefix}preset`) {\n        presetName = attr.value.trim()\n        return\n      }\n      if (attr.name.startsWith(AF.Config.prefix)) {\n        const components = this.extractAttributeComponents(attr.name)\n        if (!components) return\n        const { type, breakpoint } = components\n        if (!this.parsers[type]) {\n          debug.warn(`Unknown attribute: ${attr.name}`)\n          return\n        }\n        let parsedData = this.runParsers(element, type, attr.value)\n        if (parsedData) {\n          parsedAttributes[type] = parsedAttributes[type] ?? {}\n          parsedAttributes[type][breakpoint] = parsedData\n          parsedAttributes[type] = this.checkIfResponsiveAttribute(parsedAttributes[type], type)\n        } else {\n          debug.warn(`Error parsing \"${type}\" attribute value: ${attr.value}`)\n        }\n      }\n    })\n    if (presetName) {\n      const presetAttributes = this.parsePresetAttributes(presetName, element)\n      this.deepMergeAttributes(parsedAttributes, presetAttributes)\n    }\n    return parsedAttributes\n  },\n\n  extractAttributeComponents (attrName) {\n    const attrUnprefixedName = attrName.slice(AF.Config.prefix.length)\n    const match = attrUnprefixedName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/)\n    if (match[2] && !AF.Config.breakpoints[match[2]]) {\n      debug.warn(`Invalid breakpoint: ${match[2]}`)\n      return null\n    }\n    return match ? { type: match[1], breakpoint: match[2] || 'default' } : null\n  },\n\n  runParsers (element, type, value) {\n    try {\n      let parsedData = {}\n      let lastValue = null\n      for (const parser of this.parsers[type].flow) {\n        parsedData = lastValue ? this[parser](lastValue, element) : this[parser](value, element)\n        lastValue = parsedData\n      }\n      return parsedData\n    } catch (error) {\n      return null\n    }\n  },\n\n  disallowEmpty (value, element) {\n    if (value === '') throw new Error(`Empty value for attribute is not allowed`)\n    return value\n  },\n\n  checkIfResponsiveAttribute (data, type) {\n    return !Parser.parsers[type].responsive ? data[Object.keys(data)[0]] : data\n  },\n\n  parsePresetAttributes (presetName, element) {\n    const preset = AF.Config.presets[presetName]\n    if (!preset) {\n      debug.warn(`Preset \"${presetName}\" not found`)\n      return {}\n    }\n    return Object.entries(preset).reduce((presetAttrs, [attrName, attrValue]) => {\n      if (attrName === 'selector') return presetAttrs\n      const [, type, breakpoint = 'default'] = attrName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/) || []\n      if (!type || !this.parsers[type]) {\n        debug.warn(`Invalid or unknown preset attribute: \"${attrName}\"`)\n        return presetAttrs\n      }\n      if (breakpoint !== 'default' && !AF.Config.breakpoints[breakpoint]) {\n        debug.warn(`Invalid breakpoint \"${breakpoint}\" in preset \"${presetName}\" for type \"${type}\"`)\n        return presetAttrs\n      }\n      let parsedData = this.runParsers(element, type, attrValue)\n      if (parsedData) {\n        presetAttrs[type] = { ...presetAttrs[type], [breakpoint]: parsedData }\n      } else {\n        debug.warn(`Error parsing \"${type}\" attribute value: ${attrValue}`)\n      }\n      return presetAttrs\n    }, {})\n  },\n\n  parseObjectAttribute (value, element) {\n    if (typeof value === 'object') return value // Already parsed\n    value = this.resolveVariables(value, element) // Resolve variables\n    value = this.escapeCommas(value) // Escape commas inside brackets\n    value = value.replace(/'/g, '\"') // Single quotes => double quotes\n      .replace(/\\s+/g, ' ').trim() // Normalize whitespace\n      .replace(/(^|[,{]\\s*)([^\\s,\"'{}[\\]:]+)(\\s*:)/g, '$1\"$2\"$3') // Quote keys (including at the start of the string)\n      .replace(/(:\\s*)([^,{}\\[\\]\\s][^,{}\\[\\]]*)(?=[,}\\]]|$)/g, (match, p1, p2) => { // Quote values, skipping arrays and objects\n        const trimmedValue = p2.trim()\n        if (trimmedValue.startsWith('[') || trimmedValue.startsWith('{')) return `${p1}${trimmedValue}` // Skip arrays and objects\n        if (/^-?\\d+(\\.\\d+)?$/.test(trimmedValue) || /^(true|false|null)$/i.test(trimmedValue)) return `${p1}${trimmedValue}` // Do not quote numbers, booleans, null\n        if (!/^\".*\"$/.test(trimmedValue)) return `${p1}\"${trimmedValue}\"` // Quote if not already quoted\n        return match\n      })\n      .replace(/__COMMA__/g, ',')\n\n    return value\n  },\n\n  escapeCommas (str) {\n    let result = ''\n    let depth = 0\n    let inQuote = false\n    let quoteChar = ''\n    const brackets = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    }\n    const stack = []\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i]\n\n      if (inQuote) {\n        result += c\n        if (c === quoteChar) {\n          inQuote = false\n        }\n      } else if (c === '\"' || c === '\\'') {\n        inQuote = true\n        quoteChar = c\n        result += c\n      } else if (brackets[c]) {\n        stack.push(brackets[c])\n        depth++\n        result += c\n      } else if (stack.length > 0 && c === stack[stack.length - 1]) {\n        stack.pop()\n        depth--\n        result += c\n      } else if (c === ',' && depth > 0) {\n        result += '__COMMA__'\n      } else {\n        result += c\n      }\n    }\n    return result\n  },\n\n  deepMergeAttributes (target, source) {\n    for (const [type, typeData] of Object.entries(source)) {\n      if (!target[type]) {\n        target[type] = utils.deepMergeObjects({}, typeData)\n        continue\n      }\n      for (const [breakpoint, value] of Object.entries(typeData)) {\n        if (!target[type][breakpoint]) {\n          target[type][breakpoint] = value\n        } else {\n          target[type][breakpoint] = utils.deepMergeObjects(target[type][breakpoint], value)\n        }\n      }\n    }\n  },\n\n  resolveVariables (str, element) {\n    let resolvedStr = str.replace(/var\\((--[^)]+)\\)/g, (match, varName) => {\n      const computedValue = getComputedStyle(element).getPropertyValue(varName).trim()\n      return computedValue || 'undefined'\n    })\n    resolvedStr = resolvedStr.replace(/\\${([^}]+)}/g, (_, p1) => this.evaluateExpression(p1.trim(), this.getElementContext(element)))\n    return resolvedStr\n  },\n\n  evaluateExpression: (() => {\n    const cache = new Map()\n    return (expression, context) => {\n      if (!cache.has(expression)) cache.set(expression, new Function('\"use strict\";return (' + expression + ')'))\n      try {\n        return cache.get(expression).call(context)\n      } catch (error) {\n        debug.error(`Error evaluating expression: ${expression}`, error)\n        return undefined\n      }\n    }\n  })(),\n\n  getElementContext (element) {\n    return {\n      $element: element,\n      window,\n      document,\n    }\n  },\n\n  parseJsonToObjectOrArray (value, element) {\n    if (typeof value === 'object') return value\n    try {\n      return JSON.parse(`{${value}}`)\n    } catch (error1) {\n      try {\n        return JSON.parse(`[${value}]`)\n      } catch (error2) {\n        debug.error('Error parsing attribute value:', value, error2)\n        return null\n      }\n    }\n  },\n\n  normalizeAttributeValues (data, depth = 0, maxDepth = 100) {\n    if (depth > maxDepth) {\n      AF.debug.error('Maximum recursion depth exceeded in normalizeAttributeValues')\n      return data\n    }\n    if (Array.isArray(data)) {\n      return data.map(value => this.normalizeAttributeValues(value, depth + 1, maxDepth))\n    }\n    if (data !== null && typeof data === 'object') {\n      return Object.fromEntries(\n        Object.entries(data).map(([key, value]) => [key, this.normalizeAttributeValues(value, depth + 1, maxDepth)])\n      )\n    }\n    return this.normalizeValue(data)\n  },\n\n  normalizeValue (value) {\n    if (typeof value === 'number') return value\n    if (typeof value !== 'string') return value\n    const trimmed = value.trim()\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) return Number(trimmed)\n    if (/^(true|false)$/i.test(trimmed)) return trimmed.toLowerCase() === 'true'\n    return value\n  },\n\n  parseTimelineValue (value) {\n    const parts = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (parts.length > 3) throw new Error(`Invalid timeline value: ${value}. Expected format: name[, position][, properties]`)\n    return parts.length === 1 ? { name: String(parts[0]), position: null } : parts.length === 2 ? { name: parts[0], position: this.normalizeValue(parts[1]) } : {\n      name: parts[0],\n      position: this.normalizeValue(parts[1]),\n      options: this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(parts[2], null), null))[0]\n    }\n  },\n\n  parseSelectorValue (value, element) {\n    return value.trim()\n  },\n\n  parseOnValue (value, element) {\n    const parts = value.split(',').map(s => s.trim())\n    return { events: parts }\n  },\n\n  parseActionValue (value, element) {\n    const [action, target, ...argParts] = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (!target || !action) {\n      throw new Error(`Invalid action format: \"${value}\", needs at least target and action.`)\n    }\n    const argStr = argParts.join(',').trim()\n    const args = argStr ? argStr.startsWith('{') && argStr.endsWith('}')\n      ? this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(argStr, element), element))\n      : this.normalizeValue(argStr) : {}\n    return {\n      action, target,\n      arguments: args\n    }\n  },\n\n  parseKeyframesValue (value, element) {\n    return value\n  },\n\n  parseSplitTextValue (value, element) {\n    if (typeof value === 'object') return value\n    if (value.includes(':')) {\n      value = this.parseObjectAttribute(value, element)\n      value = this.parseJsonToObjectOrArray(value, element)\n      value = this.normalizeAttributeValues(value)\n      return value\n    }\n    const types = value.split(',').map(s => s.trim()).filter(s => s.length > 0)\n    return { type: types.join(', ') }\n  },\n\n  parseEmptyValue (value, element) {\n    return true\n  },\n\n  getTimelines (elements) {\n    const timelines = {}\n    const processBreakpoint = (item, bp) => {\n      const { attributes, element, targets } = item\n      const timelineName = attributes.timeline?.[bp]?.name ?? attributes.timeline?.default?.name ?? (element.id.length ? element.id : null) ?? utils.generateRandomName()\n      timelines[bp] ??= {}\n      timelines[bp][timelineName] ??= { animations: [], options: {} }\n      const bpAttrs = Object.fromEntries(\n        Object.entries(attributes)\n          .filter(([, value]) => value[bp] || (value.default && bp === 'default'))\n          .map(([key, value]) => [key, value[bp] ?? value.default])\n      )\n      timelines[bp][timelineName].animations.push({ element, attributes: bpAttrs, targets })\n      if (Object.keys(timelines[bp][timelineName].options).length === 0) {\n        timelines[bp][timelineName].options = this.getTimelineOptions(attributes.timeline)\n      }\n    }\n    elements.forEach(item => {\n      const usedBreakpoints = new Set(Object.values(item.attributes).flatMap(attr => Object.keys(attr)))\n      if (usedBreakpoints.has('default')) {\n        usedBreakpoints.delete('default')\n        processBreakpoint(item, 'default')\n      }\n      usedBreakpoints.forEach(bp => processBreakpoint(item, bp))\n    })\n    return Object.fromEntries(Object.entries(timelines).filter(([key]) => isNaN(key)))\n  },\n\n  getTimelineOptions (timeline) {\n    if (!timeline) return {}\n    for (const key in timeline) {\n      if (timeline[key] && timeline[key].options) return timeline[key].options\n    }\n    return {}\n  },\n\n}\n\nconst AF = {\n\n  debug,\n  utils,\n  Parser,\n  Config,\n  engines: {},\n  engineInstance: null,\n\n  registerEngine (name, engineClass, plugins) {\n    AF.engines[name] = {}\n    AF.engines[name].engineClass = engineClass\n  },\n\n  init (config = null) {\n    if (!AF.engines) return\n    if (config) AF.utils.mergeConfig(config)\n    this.observeDOM()\n    this.initAnimations()\n  },\n\n  initAnimations () {\n    const elements = Parser.parseElements()\n    elements.forEach(elementData => {\n      elementData.element.setAttribute('data-af-processed', 'true')\n    })\n    const timelines = Parser.getTimelines(elements)\n    const EngineClass = AF.engines[Config.engine].engineClass\n    if (!EngineClass) {\n      this.debug.error(`Incorrect animation engine: ${AF.Config.engine}`)\n      return\n    }\n    if (!this.engineInstance) {\n      this.engineInstance = new EngineClass(elements, timelines)\n      if (this.engineInstance.init && typeof this.engineInstance.init === 'function') {\n        this.engineInstance.init(AF.Config)\n      }\n    } else {\n      this.engineInstance.update(elements, timelines)\n    }\n  },\n\n  observeDOM () {\n    const observer = new MutationObserver((mutationsList) => {\n      let nodesAdded = false\n      for (const mutation of mutationsList) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          nodesAdded = true\n          break\n        }\n      }\n      if (nodesAdded) this.render()\n    })\n    observer.observe(document.body, { childList: true, subtree: true })\n  },\n\n  render () {\n    const elements = Parser.getAnimatableElements().filter(element => !element.hasAttribute('data-af-processed'))\n    if (elements.length === 0) return\n    elements.forEach(element => {\n      element.setAttribute('data-af-processed', 'true')\n    })\n    const parsedElements = Parser.processAttributes(elements)\n    const timelines = Parser.getTimelines(parsedElements)\n    if (this.engineInstance) {\n      this.engineInstance.update(parsedElements, timelines)\n    } else {\n      this.engineInstance = new (AF.engines[AF.Config.engine].engineClass)(parsedElements, timelines)\n      if (this.engineInstance.init && typeof this.engineInstance.init === 'function') {\n        this.engineInstance.init(AF.Config)\n      }\n    }\n  },\n\n}\n\nexport default AF","import AF from './af-core.js'\n\nclass AFEngineGSAP {\n\n  gsapTimelines = []\n  elements = []\n  timelines = {}\n  matchMedia = null\n  gsap = null\n  plugins = null\n\n  defaults = {\n    scrollTrigger: {\n      start: 'top 90%',\n      end: 'bottom 10%',\n      toggleActions: 'play reverse play reverse',\n      scrub: false,\n      invalidateOnRefresh: true\n    },\n    scrollSmoother: {\n      enabled: false,\n      options: {\n        smooth: 1,\n        effects: true,\n        smoothTouch: 0.1,\n      }\n    },\n    allDefaults: {\n      force3D: true,\n      lazy: false,\n    },\n    actions: {\n      play: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          timeline.play()\n        }\n      },\n      pause: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.pause()\n      },\n      restart: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.restart()\n      },\n      reverse: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.reverse()\n      },\n      toggle: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          if (!timeline.reversed()) {\n            timeline.reverse()\n          } else {\n            timeline.play()\n          }\n        }\n      },\n    },\n  }\n\n  constructor (elements, timelines) {\n    this.elements = elements\n    this.timelines = timelines\n  }\n\n  init (config) {\n    AF.Config = config\n    if (!AF.Config?.plugins?.gsap && !window.gsap) {\n      AF.debug.error('GSAP core not found')\n      return\n    }\n    this.gsap = AF.Config?.plugins?.gsap || window.gsap\n    this.plugins = AF.Config?.plugins || {}\n    this.loadRequiredPlugins(this.elements)\n    this.initScrollSmoother()\n    this.matchMedia = this.gsap.matchMedia()\n    this.animate()\n  }\n\n  loadRequiredPlugins (elements) {\n    if (AF.utils.hasElementsWithAttributes(elements, ['scroll'])) {\n      this.plugins.ScrollTrigger = this.plugins?.ScrollTrigger || ScrollTrigger\n      this.gsap.registerPlugin(this.plugins.ScrollTrigger)\n    }\n    if (AF.utils.hasElementsWithAttributes(elements, ['splittext'])) {\n      this.plugins.SplitText = this.plugins?.SplitText || SplitText\n      this.gsap.registerPlugin(this.plugins.SplitText)\n    }\n  }\n\n  animate () {\n    if (!this.timelines) return\n    for (const [bp, timelines] of Object.entries(this.timelines)) {\n      this.matchMedia.add(AF.Config.breakpoints[bp], (context) => {\n        for (let [tlName, tl] of Object.entries(timelines)) {\n          // Check if this timeline has already been initialized\n          if (this.isTimelineInitialized(tlName, bp)) {\n            continue\n          }\n          // Initialize the timeline\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: bp, timeline: tlInstance })\n          for (const animation of tl.animations) {\n            const animationInstance = this.createSingleAnimation(animation, bp)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          }\n        }\n        this.setupEventActions(bp, context)\n      })\n    }\n    this.handleResize()\n    this.handlePageShow()\n    this.handleLoad()\n    this.refresh()\n  }\n\n  update (newElements, newTimelines) {\n    this.elements = [...this.elements, ...newElements]\n    for (const [bp, timelines] of Object.entries(newTimelines)) {\n      if (!this.timelines[bp]) {\n        this.timelines[bp] = timelines\n      } else {\n        Object.assign(this.timelines[bp], timelines)\n      }\n    }\n    this.animateNewElements(newElements, newTimelines)\n  }\n\n  animateNewElements (elements, timelines) {\n    if (!timelines) return\n    for (const [bp, bpTimelines] of Object.entries(timelines)) {\n      this.matchMedia.add(AF.Config.breakpoints[bp], (context) => {\n        for (let [tlName, tl] of Object.entries(bpTimelines)) {\n          if (this.isTimelineInitialized(tlName, bp)) {\n            continue\n          }\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: bp, timeline: tlInstance })\n          for (const animation of tl.animations) {\n            const animationInstance = this.createSingleAnimation(animation, bp)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          }\n        }\n        this.setupEventActions(bp, context)\n      })\n    }\n    this.refresh()\n  }\n\n  isTimelineInitialized (tlName, breakpoint) {\n    return this.gsapTimelines.some(tl => tl.name === tlName && tl.breakpoint === breakpoint)\n  }\n\n  setupEventActions (breakpoint, context) {\n    this.elements.forEach(elementData => {\n      const { element, attributes, targets } = elementData\n      if (attributes?.on?.[breakpoint] && attributes?.action?.[breakpoint]) {\n        const events = attributes.on[breakpoint].events\n        const actionData = attributes.action[breakpoint]\n        events.forEach(eventName => {\n          targets.forEach(target => {\n            const handler = (event) => {\n              this.handleAction(actionData.action, actionData.target, actionData.arguments, event, breakpoint)\n            }\n            context.add(() => {\n              target.addEventListener(eventName, handler)\n              return () => {\n                target.removeEventListener(eventName, handler)\n              }\n            })\n          })\n        })\n      }\n    })\n  }\n\n  handleAction (actionName, actionTarget, actionArgs, event, breakpoint) {\n    if (typeof this.defaults.actions[actionName] === 'function') {\n      this.defaults.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else if (typeof AF.Config.actions[actionName] === 'function') {\n      AF.Config.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else {\n      AF.debug.warn(`Action \"${actionName}\" not found.`)\n    }\n  }\n\n  getTimelineByName (name, breakpoint) {\n    const timelineEntry = this.gsapTimelines.find(tl => tl.name === name && tl.breakpoint === breakpoint)\n    return timelineEntry ? timelineEntry.timeline : null\n  }\n\n  refresh () {\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.update()\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.getAll().forEach(trigger => trigger.refresh())\n  }\n\n  handleLoad () {\n    window.addEventListener('load', () => this.refresh())\n  }\n\n  handleResize () {\n    window.addEventListener('resize', AF.utils.debounce(() => this.refresh(), 200), { passive: true })\n  }\n\n  handlePageShow () {\n    window.addEventListener('pageshow', (event) => event.persisted && this.refresh() && this.animate())\n  }\n\n  getConfig (key) {\n    return AF.Config[key] ?? this.defaults[key] ?? null\n  }\n\n  getScrollTrigger (attributes, element) {\n    if (!attributes.scroll) return {}\n    let scrollAttributes = Object.keys(attributes.scroll).length === 0 ? this.getConfig('scrollTrigger') : attributes.scroll\n    return { scrollTrigger: { trigger: element, ...scrollAttributes } }\n  }\n\n  getSplitText (attributes, targets) {\n    if (!attributes.splittext) return targets\n    const splitTextOptions = attributes.splittext\n    const split = new this.plugins.SplitText(targets, splitTextOptions)\n    const typeString = splitTextOptions.type || ''\n    const types = typeString.split(',').map(s => s.trim())\n    let animationTargets = []\n    if (types.includes('chars')) animationTargets = animationTargets.concat(split.chars)\n    if (types.includes('words')) animationTargets = animationTargets.concat(split.words)\n    if (types.includes('lines')) animationTargets = animationTargets.concat(split.lines)\n    if (animationTargets.length === 0) animationTargets = targets\n    return animationTargets\n  }\n\n  prepareTimeline (tl) {\n    let scrollTrigger = null\n    let pause = false\n    tl.animations.forEach(animation => {\n      if (animation.attributes?.scroll) {\n        scrollTrigger = !scrollTrigger ? { scroll: animation.attributes.scroll ?? scrollTrigger, scrollElement: animation.element ?? scrollElement } : scrollTrigger\n        delete animation.attributes.scroll\n      }\n      if (animation.attributes?.pause) {\n        pause = !pause ? { pause: true } : pause\n        delete animation.attributes.pause\n      }\n    })\n    return { ...tl, ...scrollTrigger, ...pause }\n  }\n\n  createSingleAnimation (animation, breakpoint) {\n    const { element, attributes, targets } = animation\n    let options = { ...this.getScrollTrigger(attributes, element), ...this.getConfig('allDefaults') }\n    let animationTargets = this.getSplitText(attributes, targets)\n    if (attributes.keyframes) return this.gsap.to(animationTargets, { keyframes: attributes.keyframes, ...attributes?.options, ...options })\n    if (attributes.from && !attributes.to) return this.gsap.from(animationTargets, { ...attributes.from, ...attributes?.options, ...options })\n    if (attributes.to && !attributes.from) return this.gsap.to(animationTargets, { ...attributes.to, ...attributes?.options, ...options })\n    if (attributes.from && attributes.to) return this.gsap.fromTo(animationTargets, attributes.from, { ...attributes.to, ...attributes?.options, ...options })\n  }\n\n  initScrollSmoother () {\n    if (!this.getConfig('scrollSmoother')?.enabled) return\n    this.plugins.ScrollSmoother = this.plugins?.ScrollSmoother || ScrollSmoother\n    this.gsap.registerPlugin(this.plugins.ScrollSmoother)\n    const content = document.querySelector('#smooth-content')\n    if (!content) {\n      AF.debug.error('ScrollSmoother: No #smooth-content found')\n      return\n    }\n    this.plugins.ScrollSmoother.create({\n      ...this.getConfig('scrollSmoother').options,\n      wrapper: '#smooth-wrapper',\n      content: '#smooth-content',\n    })\n  }\n\n  cleanup () {\n    this.gsapTimelines = this.gsapTimelines.filter(({ timeline, name, breakpoint }) => {\n      const timelineExists = this.elements.some(elData => {\n        return elData.attributes.timeline?.[breakpoint]?.name === name\n      })\n      if (!timelineExists) {\n        timeline.kill()\n        return false\n      }\n      return true\n    })\n  }\n\n}\n\nAF.registerEngine('gsap', AFEngineGSAP)\n\nexport default AF"],"names":["Config","prefix","breakpoints","sm","md","lg","xl","xxl","engine","debug","log","args","AF","console","warn","error","utils","hasAnimationAttributes","element","Array","from","attributes","some","attr","name","startsWith","deepMergeObjects","target","source","isArray","slice","output","Object","keys","forEach","key","this","mergeConfig","config","hasElementsWithAttributes","elements","includes","generateRandomName","Math","random","toString","substring","kebabCase","str","replace","toLowerCase","debounce","func","wait","timeout","clearTimeout","setTimeout","getBreakpointMaxWidth","query","maxWidthMatch","match","minWidthMatch","parseInt","Infinity","Parser","parsers","timeline","flow","responsive","to","keyframes","options","on","action","scroll","splittext","pause","parseElements","Set","getAnimatableElements","getAnimatableElementsByPreset","processAttributes","presets","entries","flatMap","presetName","preset","className","document","getElementsByClassName","map","setAttribute","parsedElements","push","parseSingleElement","propagateBreakpoints","parseElementAttributes","targets","getTargets","data","configBreakpoints","sort","a","b","aWidth","attrKey","attrValue","hasDefault","filter","bp","propagatedValues","default","elementData","targetSelector","trim","subSelector","matchedElements","getMatchedElements","length","querySelectorAll","matches","children","child","parsedAttributes","components","extractAttributeComponents","type","breakpoint","parsedData","runParsers","value","checkIfResponsiveAttribute","presetAttributes","parsePresetAttributes","deepMergeAttributes","attrName","lastValue","parser","disallowEmpty","Error","reduce","presetAttrs","parseObjectAttribute","resolveVariables","escapeCommas","p1","p2","trimmedValue","test","result","depth","inQuote","quoteChar","brackets","stack","i","c","pop","typeData","resolvedStr","varName","getComputedStyle","getPropertyValue","_","evaluateExpression","getElementContext","cache","Map","expression","context","has","set","Function","get","call","$element","window","parseJsonToObjectOrArray","JSON","parse","error1","error2","normalizeAttributeValues","maxDepth","fromEntries","normalizeValue","trimmed","Number","parseTimelineValue","parts","split","s","String","position","parseSelectorValue","parseOnValue","events","parseActionValue","argParts","argStr","join","arguments","endsWith","parseKeyframesValue","parseSplitTextValue","parseEmptyValue","getTimelines","timelines","processBreakpoint","item","timelineName","id","animations","bpAttrs","getTimelineOptions","usedBreakpoints","values","delete","isNaN","engines","engineInstance","registerEngine","engineClass","plugins","init","observeDOM","initAnimations","EngineClass","update","MutationObserver","mutationsList","nodesAdded","mutation","addedNodes","render","observe","body","childList","subtree","hasAttribute","gsapTimelines","matchMedia","gsap","defaults","scrollTrigger","start","end","toggleActions","scrub","invalidateOnRefresh","scrollSmoother","enabled","smooth","effects","smoothTouch","allDefaults","force3D","lazy","actions","play","event","getTimelineByName","restart","reverse","toggle","reversed","constructor","loadRequiredPlugins","initScrollSmoother","animate","ScrollTrigger","registerPlugin","SplitText","add","tlName","tl","isTimelineInitialized","prepareTimeline","getScrollTrigger","scrollElement","tlInstance","animation","animationInstance","createSingleAnimation","setupEventActions","handleResize","handlePageShow","handleLoad","refresh","newElements","newTimelines","assign","animateNewElements","bpTimelines","actionData","eventName","handler","handleAction","addEventListener","removeEventListener","actionName","actionTarget","actionArgs","timelineEntry","find","getAll","trigger","passive","persisted","getConfig","getSplitText","splitTextOptions","types","animationTargets","concat","chars","words","lines","fromTo","ScrollSmoother","querySelector","create","wrapper","content","cleanup","elData","kill"],"mappings":"mOAAA,IAAIA,EAAS,CACXC,OAAQ,MACRC,YAAa,CACXC,GAAI,qBACJC,GAAI,4CACJC,GAAI,6CACJC,GAAI,8CACJC,IAAK,uBAEPC,OAAQ,OACRC,OAAO,GAKT,MAAMA,EAAQ,CACZC,IAAK,IAAIC,KAAWC,EAAGZ,OAAOS,OAASI,QAAQH,IAAI,UAAWC,EAAI,EAClEG,KAAM,IAAIH,KAAWC,EAAGZ,OAAOS,OAASI,QAAQC,KAAK,UAAWH,EAAI,EACpEI,MAAO,IAAIJ,KAAWC,EAAGZ,OAAOS,OAASI,QAAQE,MAAM,UAAWJ,EAAI,GAGlEK,EAAQ,CAEZC,uBAAwBC,GACfC,MAAMC,KAAKF,EAAQG,YAAYC,MAAKC,GAAQA,EAAKC,KAAKC,WAAWb,EAAGZ,OAAOC,UAGpF,gBAAAyB,CAAkBC,EAAQC,GACxB,GAAIT,MAAMU,QAAQF,IAAWR,MAAMU,QAAQD,GACzC,OAAOA,EAAOE,QACT,GAAIX,MAAMU,QAAQD,GACvB,OAAOA,EAAOE,QACT,GAAIX,MAAMU,QAAQF,GACvB,OAAOC,EACF,GAAsB,iBAAXD,GAAyC,iBAAXC,GAAkC,OAAXD,GAA8B,OAAXC,EAAiB,CACzG,MAAMG,EAAS,IAAKJ,GAIpB,OAHAK,OAAOC,KAAKL,GAAQM,SAAQC,IAC1BJ,EAAOI,GAAOC,KAAKV,iBAAiBC,EAAOQ,GAAMP,EAAOO,GAAK,IAExDJ,CACb,CACM,OAAOH,CAEV,EAED,WAAAS,CAAaC,GACX1B,EAAGZ,OAASoC,KAAKV,iBAAiBd,EAAGZ,OAAQsC,GAC7C1B,EAAGZ,OAAOE,YAAcoC,EAAOpC,aAAeU,EAAGZ,OAAOE,WACzD,EAEDqC,0BAA0B,CAACC,EAAUnB,IAC5BmB,EAASlB,MAAKJ,GAAWG,EAAWC,MAAKC,GAAQS,OAAOC,KAAKf,EAAQG,YAAYoB,SAASlB,OAGnGmB,mBAAmB,IACVC,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,IAGjDC,UAAWC,GACFA,EAAIC,QAAQ,qBAAsB,SAASC,cAGpD,QAAAC,CAAUC,EAAMC,GACd,IAAIC,EACJ,OAAO,YAA8B3C,GAKnC4C,aAAaD,GACbA,EAAUE,YALI,KACZD,aAAaD,GACbF,KAAQzC,EAAK,GAGa0C,EAC7B,CACF,EAED,qBAAAI,CAAuBC,GACrB,MAAMC,EAAgBD,EAAME,MAAM,4BAC5BC,EAAgBH,EAAME,MAAM,4BAClC,OAAID,EACKG,SAASH,EAAc,IACrBE,EACFE,IAEF,CACR,GAIGC,EAAS,CAEbC,QAAS,CACPC,SAAU,CAAEC,KAAM,CAAC,gBAAiB,sBAAuBC,YAAY,GACvEhD,KAAM,CAAE+C,KAAM,CAAC,gBAAiB,uBAAwB,2BAA4B,4BAA6BC,YAAY,GAC7HC,GAAI,CAAEF,KAAM,CAAC,gBAAiB,uBAAwB,2BAA4B,4BAA6BC,YAAY,GAC3HE,UAAW,CAAEH,KAAM,CAAC,gBAAiB,uBAAwB,2BAA4B,2BAA4B,uBAAwBC,YAAY,GACzJG,QAAS,CAAEJ,KAAM,CAAC,gBAAiB,uBAAwB,2BAA4B,4BAA6BC,YAAY,GAChIzC,OAAQ,CAAEwC,KAAM,CAAC,sBAAuBC,YAAY,GACpDI,GAAI,CAAEL,KAAM,CAAC,gBAAiB,gBAAiBC,YAAY,GAC3DK,OAAQ,CAAEN,KAAM,CAAC,gBAAiB,oBAAqBC,YAAY,GACnEM,OAAQ,CAAEP,KAAM,CAAC,uBAAwB,2BAA4B,4BAA6BC,YAAY,GAC9GO,UAAW,CAAER,KAAM,CAAC,uBAAwBC,YAAY,GACxDQ,MAAO,CAAET,KAAM,CAAC,mBAAoBC,YAAY,IAGlD,aAAAS,GACE,MAAMrC,EAAWrB,MAAMC,KAAK,IAAI0D,IAAI,IAAI1C,KAAK2C,2BAA4B3C,KAAK4C,mCAC9E,GAAKxC,EACL,OAAOJ,KAAK6C,kBAAkBzC,EAC/B,EAEDwC,8BAA8B,IACvBpE,EAAGZ,OAAOkF,QACRlD,OAAOmD,QAAQvE,EAAGZ,OAAOkF,SAASE,SAAQ,EAAEC,EAAYC,MAC7D,MAAMC,EAAY,GAAG3E,EAAGZ,OAAOC,SAASe,EAAM+B,UAAUsC,KACxD,MAAO,IAAIG,SAASC,uBAAuBF,IAAYG,KAAIxE,IACzDA,EAAQyE,aAAa,GAAG/E,EAAGZ,OAAOC,eAAgBoF,GAC3CnE,IACR,IAN4B,GAUjC,iBAAA+D,CAAmBzC,GACjB,IAAKA,EAAU,OACf,IAAIoD,EAAiB,GAUrB,OATApD,EAASN,SAAQhB,IACf,IACE0E,EAAeC,KAAKzD,KAAK0D,mBAAmB5E,GACpD,CAAQ,MAEA,OADAT,EAAMM,MAAM,uBAAwBG,GAC7B0E,CACR,KAEHA,EAAiBxD,KAAK2D,qBAAqBH,GACpCA,CACR,EAED,kBAAAE,CAAoB5E,GAClB,MAAMG,EAAae,KAAK4D,uBAAuB9E,GAE/C,MAAO,CAAEA,UAASG,aAAY4E,QADd7D,KAAK8D,WAAW,CAAEhF,UAASG,eAE5C,EAED,oBAAA0E,CAAsBI,GACpB,MAAMC,EAAoBpE,OAAOC,KAAKrB,EAAGZ,OAAOE,aAAamG,MAAK,CAACC,EAAGC,KACpE,MAAMC,EAASxF,EAAMyC,sBAAsB7C,EAAGZ,OAAOE,YAAYoG,IAEjE,OADetF,EAAMyC,sBAAsB7C,EAAGZ,OAAOE,YAAYqG,IACjDC,KAElB,OAAOL,EAAKT,KAAIxE,IACd,IAAK,MAAOuF,EAASC,KAAc1E,OAAOmD,QAAQjE,EAAQG,YACxD,GAAIe,KAAK6B,QAAQwC,IAAYrE,KAAK6B,QAAQwC,GAASrC,WAAY,CAC7D,MAAMuC,EAAa,YAAaD,EACL1E,OAAOC,KAAKyE,GAAWE,QAAOC,GAAa,YAAPA,GAAoBA,KAAMjG,EAAGZ,OAAOE,cACnG,IAAI4G,EAAmB,CAAE,EACrBH,IACFG,EAAmB9F,EAAMU,iBAAiB,CAAA,EAAIgF,EAAUK,UAE1DX,EAAkBlE,SAAQ2E,IACpBA,KAAMH,IACRI,EAAmB9F,EAAMU,iBAAiBoF,EAAkBJ,EAAUG,KAExE3F,EAAQG,WAAWoF,GAASI,GAAM7F,EAAMU,iBAAiB,CAAE,EAAEoF,EAAiB,IAE5EH,UACKzF,EAAQG,WAAWoF,GAASM,OAEtC,CAEH,OAAO7F,IAEV,EAED,UAAAgF,CAAYc,GACV,GAAuC,MAAnCA,EAAY3F,YAAYM,SAAmBqF,EAAY3F,YAAYM,OAAQ,MAAO,CAACqF,EAAY9F,SACnG,MAAM+F,EAAiBD,EAAY3F,WAAWM,OAAOuF,OAC/CC,EAAcF,EAAenF,MAAM,GAAGoF,OAC5C,GAAID,EAAexF,WAAW,KAAM,CAClC,MAAM2F,EAAkBhF,KAAKiF,mBAAmBL,EAAY9F,QAASiG,GACrE,OAAOC,EAAgBE,OAASF,EAAkB,CAACJ,EAAY9F,QAChE,CACD,OAAOsE,SAAS+B,iBAAiBN,EAClC,EAEDI,mBAAmB,CAACnG,EAASiG,IACvBA,EAAYvD,MAAM,cAAgB1C,EAAQsG,QAAQL,GAAqB,CAACjG,GACxEiG,EAAY1F,WAAW,KAAa,IAAIP,EAAQuG,UAAUb,QAAOc,GAASA,EAAMF,QAAQL,EAAYrF,MAAM,GAAGoF,UAC1G,IAAIhG,EAAQqG,iBAAiBJ,IAGtCpC,sBAAsB,IACH5D,MAAMC,KAAKoE,SAAS+B,iBAAiB,MACtCX,QAAO1F,GACrBC,MAAMC,KAAKF,EAAQG,YAAYC,MAAKC,GAAQA,EAAKC,KAAKC,WAAWb,EAAGZ,OAAOC,YAI/E,sBAAA+F,CAAwB9E,GACtB,IAAIyG,EAAmB,CAAE,EACrBtC,EAAa,KAwBjB,GAvBAlE,MAAMC,KAAKF,EAAQG,YAAYa,SAAQX,IACrC,GAAIA,EAAKC,OAAS,GAAGZ,EAAGZ,OAAOC,gBAI/B,GAAIsB,EAAKC,KAAKC,WAAWb,EAAGZ,OAAOC,QAAS,CAC1C,MAAM2H,EAAaxF,KAAKyF,2BAA2BtG,EAAKC,MACxD,IAAKoG,EAAY,OACjB,MAAME,KAAEA,EAAIC,WAAEA,GAAeH,EAC7B,IAAKxF,KAAK6B,QAAQ6D,GAEhB,YADArH,EAAMK,KAAK,sBAAsBS,EAAKC,QAGxC,IAAIwG,EAAa5F,KAAK6F,WAAW/G,EAAS4G,EAAMvG,EAAK2G,OACjDF,GACFL,EAAiBG,GAAQH,EAAiBG,IAAS,CAAE,EACrDH,EAAiBG,GAAMC,GAAcC,EACrCL,EAAiBG,GAAQ1F,KAAK+F,2BAA2BR,EAAiBG,GAAOA,IAEjFrH,EAAMK,KAAK,kBAAkBgH,uBAA0BvG,EAAK2G,QAE/D,OAnBC7C,EAAa9D,EAAK2G,MAAMhB,MAmBzB,IAEC7B,EAAY,CACd,MAAM+C,EAAmBhG,KAAKiG,sBAAsBhD,EAAYnE,GAChEkB,KAAKkG,oBAAoBX,EAAkBS,EAC5C,CACD,OAAOT,CACR,EAED,0BAAAE,CAA4BU,GAC1B,MACM3E,EADqB2E,EAASzG,MAAMlB,EAAGZ,OAAOC,OAAOqH,QAC1B1D,MAAM,qCACvC,OAAIA,EAAM,KAAOhD,EAAGZ,OAAOE,YAAY0D,EAAM,KAC3CnD,EAAMK,KAAK,uBAAuB8C,EAAM,MACjC,MAEFA,EAAQ,CAAEkE,KAAMlE,EAAM,GAAImE,WAAYnE,EAAM,IAAM,WAAc,IACxE,EAED,UAAAqE,CAAY/G,EAAS4G,EAAMI,GACzB,IACE,IAAIF,EAAa,CAAE,EACfQ,EAAY,KAChB,IAAK,MAAMC,KAAUrG,KAAK6B,QAAQ6D,GAAM3D,KACtC6D,EAAaQ,EAAYpG,KAAKqG,GAAQD,EAAWtH,GAAWkB,KAAKqG,GAAQP,EAAOhH,GAChFsH,EAAYR,EAEd,OAAOA,CACR,CAAC,MAAOjH,GACP,OAAO,IACR,CACF,EAED,aAAA2H,CAAeR,EAAOhH,GACpB,GAAc,KAAVgH,EAAc,MAAM,IAAIS,MAAM,4CAClC,OAAOT,CACR,EAEDC,2BAA2B,CAAChC,EAAM2B,IACxB9D,EAAOC,QAAQ6D,GAAM1D,WAA0C+B,EAA7BA,EAAKnE,OAAOC,KAAKkE,GAAM,IAGnE,qBAAAkC,CAAuBhD,EAAYnE,GACjC,MAAMoE,EAAS1E,EAAGZ,OAAOkF,QAAQG,GACjC,OAAKC,EAIEtD,OAAOmD,QAAQG,GAAQsD,QAAO,CAACC,GAAcN,EAAU7B,MAC5D,GAAiB,aAAb6B,EAAyB,OAAOM,EACpC,MAAS,CAAAf,EAAMC,EAAa,WAAaQ,EAAS3E,MAAM,sCAAwC,GAChG,IAAKkE,IAAS1F,KAAK6B,QAAQ6D,GAEzB,OADArH,EAAMK,KAAK,yCAAyCyH,MAC7CM,EAET,GAAmB,YAAfd,IAA6BnH,EAAGZ,OAAOE,YAAY6H,GAErD,OADAtH,EAAMK,KAAK,uBAAuBiH,iBAA0B1C,gBAAyByC,MAC9Ee,EAET,IAAIb,EAAa5F,KAAK6F,WAAW/G,EAAS4G,EAAMpB,GAMhD,OALIsB,EACFa,EAAYf,GAAQ,IAAKe,EAAYf,GAAOC,CAACA,GAAaC,GAE1DvH,EAAMK,KAAK,kBAAkBgH,uBAA0BpB,KAElDmC,IACN,KArBDpI,EAAMK,KAAK,WAAWuE,gBACf,CAAE,EAqBZ,EAED,oBAAAyD,CAAsBZ,EAAOhH,GAC3B,MAAqB,iBAAVgH,EAA2BA,GACtCA,EAAQ9F,KAAK2G,iBAAiBb,EAAOhH,GAErCgH,GADAA,EAAQ9F,KAAK4G,aAAad,IACZjF,QAAQ,KAAM,KACzBA,QAAQ,OAAQ,KAAKiE,OACrBjE,QAAQ,sCAAuC,YAC/CA,QAAQ,gDAAgD,CAACW,EAAOqF,EAAIC,KACnE,MAAMC,EAAeD,EAAGhC,OACxB,OAAIiC,EAAa1H,WAAW,MAAQ0H,EAAa1H,WAAW,MACxD,kBAAkB2H,KAAKD,IAAiB,uBAAuBC,KAAKD,GADC,GAAGF,IAAKE,IAE5E,SAASC,KAAKD,GACZvF,EADkC,GAAGqF,KAAME,IAC3CvF,IAERX,QAAQ,aAAc,KAG1B,EAED,YAAA+F,CAAchG,GACZ,IAAIqG,EAAS,GACTC,EAAQ,EACRC,GAAU,EACVC,EAAY,GAChB,MAAMC,EAAW,CACf,IAAK,IACL,IAAK,IACL,IAAK,KAEDC,EAAQ,GAEd,IAAK,IAAIC,EAAI,EAAGA,EAAI3G,EAAIsE,OAAQqC,IAAK,CACnC,MAAMC,EAAI5G,EAAI2G,GAEVJ,GACFF,GAAUO,EACNA,IAAMJ,IACRD,GAAU,IAEG,MAANK,GAAmB,MAANA,GACtBL,GAAU,EACVC,EAAYI,EACZP,GAAUO,GACDH,EAASG,IAClBF,EAAM7D,KAAK4D,EAASG,IACpBN,IACAD,GAAUO,GACDF,EAAMpC,OAAS,GAAKsC,IAAMF,EAAMA,EAAMpC,OAAS,IACxDoC,EAAMG,MACNP,IACAD,GAAUO,GAEVP,GADe,MAANO,GAAaN,EAAQ,EACpB,YAEAM,CAEb,CACD,OAAOP,CACR,EAED,mBAAAf,CAAqB3G,EAAQC,GAC3B,IAAK,MAAOkG,EAAMgC,KAAa9H,OAAOmD,QAAQvD,GAC5C,GAAKD,EAAOmG,GAIZ,IAAK,MAAOC,EAAYG,KAAUlG,OAAOmD,QAAQ2E,GAC1CnI,EAAOmG,GAAMC,GAGhBpG,EAAOmG,GAAMC,GAAc/G,EAAMU,iBAAiBC,EAAOmG,GAAMC,GAAaG,GAF5EvG,EAAOmG,GAAMC,GAAcG,OAL7BvG,EAAOmG,GAAQ9G,EAAMU,iBAAiB,CAAA,EAAIoI,EAW/C,EAED,gBAAAf,CAAkB/F,EAAK9B,GACrB,IAAI6I,EAAc/G,EAAIC,QAAQ,qBAAqB,CAACW,EAAOoG,IACnCC,iBAAiB/I,GAASgJ,iBAAiBF,GAAS9C,QAClD,cAG1B,OADA6C,EAAcA,EAAY9G,QAAQ,gBAAgB,CAACkH,EAAGlB,IAAO7G,KAAKgI,mBAAmBnB,EAAG/B,OAAQ9E,KAAKiI,kBAAkBnJ,MAChH6I,CACR,EAEDK,mBAAoB,MAClB,MAAME,EAAQ,IAAIC,IAClB,MAAO,CAACC,EAAYC,KACbH,EAAMI,IAAIF,IAAaF,EAAMK,IAAIH,EAAY,IAAII,SAAS,wBAA0BJ,EAAa,MACtG,IACE,OAAOF,EAAMO,IAAIL,GAAYM,KAAKL,EACnC,CAAC,MAAO1J,GAEP,YADAN,EAAMM,MAAM,gCAAgCyJ,IAAczJ,EAE3D,EAEJ,EAXmB,GAapBsJ,kBAAmBnJ,IACV,CACL6J,SAAU7J,EACV8J,cACAxF,oBAIJ,wBAAAyF,CAA0B/C,EAAOhH,GAC/B,GAAqB,iBAAVgH,EAAoB,OAAOA,EACtC,IACE,OAAOgD,KAAKC,MAAM,IAAIjD,KACvB,CAAC,MAAOkD,GACP,IACE,OAAOF,KAAKC,MAAM,IAAIjD,KACvB,CAAC,MAAOmD,GAEP,OADA5K,EAAMM,MAAM,iCAAkCmH,EAAOmD,GAC9C,IACR,CACF,CACF,EAED,wBAAAC,CAA0BnF,EAAMmD,EAAQ,EAAGiC,EAAW,KACpD,OAAIjC,EAAQiC,GACV3K,EAAGH,MAAMM,MAAM,gEACRoF,GAELhF,MAAMU,QAAQsE,GACTA,EAAKT,KAAIwC,GAAS9F,KAAKkJ,yBAAyBpD,EAAOoB,EAAQ,EAAGiC,KAE9D,OAATpF,GAAiC,iBAATA,EACnBnE,OAAOwJ,YACZxJ,OAAOmD,QAAQgB,GAAMT,KAAI,EAAEvD,EAAK+F,KAAW,CAAC/F,EAAKC,KAAKkJ,yBAAyBpD,EAAOoB,EAAQ,EAAGiC,OAG9FnJ,KAAKqJ,eAAetF,EAC5B,EAED,cAAAsF,CAAgBvD,GACd,GAAqB,iBAAVA,EAAoB,OAAOA,EACtC,GAAqB,iBAAVA,EAAoB,OAAOA,EACtC,MAAMwD,EAAUxD,EAAMhB,OACtB,MAAI,kBAAkBkC,KAAKsC,GAAiBC,OAAOD,GAC/C,kBAAkBtC,KAAKsC,GAA2C,SAA1BA,EAAQxI,cAC7CgF,CACR,EAED,kBAAA0D,CAAoB1D,GAClB,MAAM2D,EAAQ3D,EAAM4D,MAAM,gBAAgBpG,KAAIqG,GAAKA,EAAE7E,SACrD,GAAI2E,EAAMvE,OAAS,EAAG,MAAM,IAAIqB,MAAM,2BAA2BT,sDACjE,OAAwB,IAAjB2D,EAAMvE,OAAe,CAAE9F,KAAMwK,OAAOH,EAAM,IAAKI,SAAU,MAA0B,IAAjBJ,EAAMvE,OAAe,CAAE9F,KAAMqK,EAAM,GAAII,SAAU7J,KAAKqJ,eAAeI,EAAM,KAAQ,CAC1JrK,KAAMqK,EAAM,GACZI,SAAU7J,KAAKqJ,eAAeI,EAAM,IACpCtH,QAASnC,KAAKkJ,yBAAyBlJ,KAAK6I,yBAAyB7I,KAAK0G,qBAAqB+C,EAAM,GAAI,MAAO,OAAO,GAE1H,EAEDK,mBAAmB,CAAChE,EAAOhH,IAClBgH,EAAMhB,OAGfiF,aAAa,CAACjE,EAAOhH,KAEZ,CAAEkL,OADKlE,EAAM4D,MAAM,KAAKpG,KAAIqG,GAAKA,EAAE7E,WAI5C,gBAAAmF,CAAkBnE,EAAOhH,GACvB,MAAOuD,EAAQ9C,KAAW2K,GAAYpE,EAAM4D,MAAM,gBAAgBpG,KAAIqG,GAAKA,EAAE7E,SAC7E,IAAKvF,IAAW8C,EACd,MAAM,IAAIkE,MAAM,2BAA2BT,yCAE7C,MAAMqE,EAASD,EAASE,KAAK,KAAKtF,OAIlC,MAAO,CACLzC,SAAQ9C,SACR8K,UALWF,EAASA,EAAO9K,WAAW,MAAQ8K,EAAOG,SAAS,KAC5DtK,KAAKkJ,yBAAyBlJ,KAAK6I,yBAAyB7I,KAAK0G,qBAAqByD,EAAQrL,GAAUA,IACxGkB,KAAKqJ,eAAec,GAAU,CAAE,EAKrC,EAEDI,oBAAoB,CAACzE,EAAOhH,IACnBgH,EAGT,mBAAA0E,CAAqB1E,EAAOhH,GAC1B,GAAqB,iBAAVgH,EAAoB,OAAOA,EACtC,GAAIA,EAAMzF,SAAS,KAIjB,OAHAyF,EAAQ9F,KAAK0G,qBAAqBZ,EAAOhH,GACzCgH,EAAQ9F,KAAK6I,yBAAyB/C,EAAOhH,GAC7CgH,EAAQ9F,KAAKkJ,yBAAyBpD,GAIxC,MAAO,CAAEJ,KADKI,EAAM4D,MAAM,KAAKpG,KAAIqG,GAAKA,EAAE7E,SAAQN,QAAOmF,GAAKA,EAAEzE,OAAS,IACpDkF,KAAK,MAC3B,EAEDK,gBAAgB,CAAC3E,EAAOhH,KACf,EAGT,YAAA4L,CAActK,GACZ,MAAMuK,EAAY,CAAE,EACdC,EAAoB,CAACC,EAAMpG,KAC/B,MAAMxF,WAAEA,EAAUH,QAAEA,EAAO+E,QAAEA,GAAYgH,EACnCC,EAAe7L,EAAW6C,WAAW2C,IAAKrF,MAAQH,EAAW6C,UAAU6C,SAASvF,OAASN,EAAQiM,GAAG7F,OAASpG,EAAQiM,GAAK,OAASnM,EAAM0B,qBAC/IqK,EAAUlG,KAAQ,CAAE,EACpBkG,EAAUlG,GAAIqG,KAAkB,CAAEE,WAAY,GAAI7I,QAAS,IAC3D,MAAM8I,EAAUrL,OAAOwJ,YACrBxJ,OAAOmD,QAAQ9D,GACZuF,QAAO,EAAC,CAAGsB,KAAWA,EAAMrB,IAAQqB,EAAMnB,SAAkB,YAAPF,IACrDnB,KAAI,EAAEvD,EAAK+F,KAAW,CAAC/F,EAAK+F,EAAMrB,IAAOqB,EAAMnB,YAEpDgG,EAAUlG,GAAIqG,GAAcE,WAAWvH,KAAK,CAAE3E,UAASG,WAAYgM,EAASpH,YACZ,IAA5DjE,OAAOC,KAAK8K,EAAUlG,GAAIqG,GAAc3I,SAAS+C,SACnDyF,EAAUlG,GAAIqG,GAAc3I,QAAUnC,KAAKkL,mBAAmBjM,EAAW6C,UAC1E,EAUH,OARA1B,EAASN,SAAQ+K,IACf,MAAMM,EAAkB,IAAIzI,IAAI9C,OAAOwL,OAAOP,EAAK5L,YAAY+D,SAAQ7D,GAAQS,OAAOC,KAAKV,MACvFgM,EAAgB7C,IAAI,aACtB6C,EAAgBE,OAAO,WACvBT,EAAkBC,EAAM,YAE1BM,EAAgBrL,SAAQ2E,GAAMmG,EAAkBC,EAAMpG,IAAI,IAErD7E,OAAOwJ,YAAYxJ,OAAOmD,QAAQ4H,GAAWnG,QAAO,EAAEzE,KAASuL,MAAMvL,KAC7E,EAED,kBAAAmL,CAAoBpJ,GAClB,IAAKA,EAAU,MAAO,CAAE,EACxB,IAAK,MAAM/B,KAAO+B,EAChB,GAAIA,EAAS/B,IAAQ+B,EAAS/B,GAAKoC,QAAS,OAAOL,EAAS/B,GAAKoC,QAEnE,MAAO,CAAE,CACV,GAIG3D,EAAK,CAETH,QACAO,QACAgD,SACAhE,SACA2N,QAAS,CAAE,EACXC,eAAgB,KAEhB,cAAAC,CAAgBrM,EAAMsM,EAAaC,GACjCnN,EAAG+M,QAAQnM,GAAQ,CAAE,EACrBZ,EAAG+M,QAAQnM,GAAMsM,YAAcA,CAChC,EAED,IAAAE,CAAM1L,EAAS,MACR1B,EAAG+M,UACJrL,GAAQ1B,EAAGI,MAAMqB,YAAYC,GACjCF,KAAK6L,aACL7L,KAAK8L,iBACN,EAED,cAAAA,GACE,MAAM1L,EAAWwB,EAAOa,gBACxBrC,EAASN,SAAQ8E,IACfA,EAAY9F,QAAQyE,aAAa,oBAAqB,OAAO,IAE/D,MAAMoH,EAAY/I,EAAO8I,aAAatK,GAChC2L,EAAcvN,EAAG+M,QAAQ3N,EAAOQ,QAAQsN,YACzCK,EAIA/L,KAAKwL,eAMRxL,KAAKwL,eAAeQ,OAAO5L,EAAUuK,IALrC3K,KAAKwL,eAAiB,IAAIO,EAAY3L,EAAUuK,GAC5C3K,KAAKwL,eAAeI,MAA4C,mBAA7B5L,KAAKwL,eAAeI,MACzD5L,KAAKwL,eAAeI,KAAKpN,EAAGZ,SAN9BoC,KAAK3B,MAAMM,MAAM,+BAA+BH,EAAGZ,OAAOQ,SAW7D,EAED,UAAAyN,GACmB,IAAII,kBAAkBC,IACrC,IAAIC,GAAa,EACjB,IAAK,MAAMC,KAAYF,EACrB,GAAsB,cAAlBE,EAAS1G,MAAwB0G,EAASC,WAAWnH,OAAS,EAAG,CACnEiH,GAAa,EACb,KACD,CAECA,GAAYnM,KAAKsM,QAAQ,IAEtBC,QAAQnJ,SAASoJ,KAAM,CAAEC,WAAW,EAAMC,SAAS,GAC7D,EAED,MAAAJ,GACE,MAAMlM,EAAWwB,EAAOe,wBAAwB6B,QAAO1F,IAAYA,EAAQ6N,aAAa,uBACxF,GAAwB,IAApBvM,EAAS8E,OAAc,OAC3B9E,EAASN,SAAQhB,IACfA,EAAQyE,aAAa,oBAAqB,OAAO,IAEnD,MAAMC,EAAiB5B,EAAOiB,kBAAkBzC,GAC1CuK,EAAY/I,EAAO8I,aAAalH,GAClCxD,KAAKwL,eACPxL,KAAKwL,eAAeQ,OAAOxI,EAAgBmH,IAE3C3K,KAAKwL,eAAiB,IAAKhN,EAAG+M,QAAQ/M,EAAGZ,OAAOQ,QAAmB,YAAEoF,EAAgBmH,GACjF3K,KAAKwL,eAAeI,MAA4C,mBAA7B5L,KAAKwL,eAAeI,MACzD5L,KAAKwL,eAAeI,KAAKpN,EAAGZ,QAGjC,UC3SHY,EAAGiN,eAAe,OAxSlB,MAEEmB,cAAgB,GAChBxM,SAAW,GACXuK,UAAY,CAAE,EACdkC,WAAa,KACbC,KAAO,KACPnB,QAAU,KAEVoB,SAAW,CACTC,cAAe,CACbC,MAAO,UACPC,IAAK,aACLC,cAAe,4BACfC,OAAO,EACPC,qBAAqB,GAEvBC,eAAgB,CACdC,SAAS,EACTpL,QAAS,CACPqL,OAAQ,EACRC,SAAS,EACTC,YAAa,KAGjBC,YAAa,CACXC,SAAS,EACTC,MAAM,GAERC,QAAS,CACPC,KAAM,CAACxO,EAAQyO,EAAOzP,EAAMoH,KAC1B,MAAM7D,EAAW9B,KAAKiO,kBAAkB1O,EAAQoG,GAC5C7D,GACFA,EAASiM,MACV,EAEHvL,MAAO,CAACjD,EAAQyO,EAAOzP,EAAMoH,KAC3B,MAAM7D,EAAW9B,KAAKiO,kBAAkB1O,EAAQoG,GAC5C7D,GAAUA,EAASU,OAAO,EAEhC0L,QAAS,CAAC3O,EAAQyO,EAAOzP,EAAMoH,KAC7B,MAAM7D,EAAW9B,KAAKiO,kBAAkB1O,EAAQoG,GAC5C7D,GAAUA,EAASoM,SAAS,EAElCC,QAAS,CAAC5O,EAAQyO,EAAOzP,EAAMoH,KAC7B,MAAM7D,EAAW9B,KAAKiO,kBAAkB1O,EAAQoG,GAC5C7D,GAAUA,EAASqM,SAAS,EAElCC,OAAQ,CAAC7O,EAAQyO,EAAOzP,EAAMoH,KAC5B,MAAM7D,EAAW9B,KAAKiO,kBAAkB1O,EAAQoG,GAC5C7D,IACGA,EAASuM,WAGZvM,EAASiM,OAFTjM,EAASqM,UAIZ,IAKP,WAAAG,CAAalO,EAAUuK,GACrB3K,KAAKI,SAAWA,EAChBJ,KAAK2K,UAAYA,CAClB,CAED,IAAAiB,CAAM1L,GACJ1B,EAAGZ,OAASsC,EACP1B,EAAGZ,QAAQ+N,SAASmB,MAASlE,OAAOkE,MAIzC9M,KAAK8M,KAAOtO,EAAGZ,QAAQ+N,SAASmB,MAAQlE,OAAOkE,KAC/C9M,KAAK2L,QAAUnN,EAAGZ,QAAQ+N,SAAW,CAAE,EACvC3L,KAAKuO,oBAAoBvO,KAAKI,UAC9BJ,KAAKwO,qBACLxO,KAAK6M,WAAa7M,KAAK8M,KAAKD,aAC5B7M,KAAKyO,WARHjQ,EAAGH,MAAMM,MAAM,sBASlB,CAED,mBAAA4P,CAAqBnO,GACf5B,EAAGI,MAAMuB,0BAA0BC,EAAU,CAAC,aAChDJ,KAAK2L,QAAQ+C,cAAgB1O,KAAK2L,SAAS+C,eAAiBA,cAC5D1O,KAAK8M,KAAK6B,eAAe3O,KAAK2L,QAAQ+C,gBAEpClQ,EAAGI,MAAMuB,0BAA0BC,EAAU,CAAC,gBAChDJ,KAAK2L,QAAQiD,UAAY5O,KAAK2L,SAASiD,WAAaA,UACpD5O,KAAK8M,KAAK6B,eAAe3O,KAAK2L,QAAQiD,WAEzC,CAED,OAAAH,GACE,GAAKzO,KAAK2K,UAAV,CACA,IAAK,MAAOlG,EAAIkG,KAAc/K,OAAOmD,QAAQ/C,KAAK2K,WAChD3K,KAAK6M,WAAWgC,IAAIrQ,EAAGZ,OAAOE,YAAY2G,IAAM4D,IAC9C,IAAK,IAAKyG,EAAQC,KAAOnP,OAAOmD,QAAQ4H,GAAY,CAElD,GAAI3K,KAAKgP,sBAAsBF,EAAQrK,GACrC,SAGFsK,EAAK/O,KAAKiP,gBAAgBF,GAC1B,MAAM5M,EAAU,IAAKnC,KAAKkP,iBAAiBH,EAAIA,GAAII,gBAC7CC,EAAapP,KAAK8M,KAAKhL,SAAS,IAAKiN,EAAG5M,WAAYA,IACtD4M,EAAGvM,OAAO4M,EAAW5M,QACzBxC,KAAK4M,cAAcnJ,KAAK,CAAErE,KAAM0P,EAAQnJ,WAAYlB,EAAI3C,SAAUsN,IAClE,IAAK,MAAMC,KAAaN,EAAG/D,WAAY,CACrC,MAAMsE,EAAoBtP,KAAKuP,sBAAsBF,EAAW5K,GAChE2K,EAAWP,IAAIS,EAAmBD,EAAUpQ,YAAY6C,UAAU+H,UAAY,EAC/E,CACF,CACD7J,KAAKwP,kBAAkB/K,EAAI4D,EAAQ,IAGvCrI,KAAKyP,eACLzP,KAAK0P,iBACL1P,KAAK2P,aACL3P,KAAK4P,SAzBgB,CA0BtB,CAED,MAAA5D,CAAQ6D,EAAaC,GACnB9P,KAAKI,SAAW,IAAIJ,KAAKI,YAAayP,GACtC,IAAK,MAAOpL,EAAIkG,KAAc/K,OAAOmD,QAAQ+M,GACtC9P,KAAK2K,UAAUlG,GAGlB7E,OAAOmQ,OAAO/P,KAAK2K,UAAUlG,GAAKkG,GAFlC3K,KAAK2K,UAAUlG,GAAMkG,EAKzB3K,KAAKgQ,mBAAmBH,EAAaC,EACtC,CAED,kBAAAE,CAAoB5P,EAAUuK,GAC5B,GAAKA,EAAL,CACA,IAAK,MAAOlG,EAAIwL,KAAgBrQ,OAAOmD,QAAQ4H,GAC7C3K,KAAK6M,WAAWgC,IAAIrQ,EAAGZ,OAAOE,YAAY2G,IAAM4D,IAC9C,IAAK,IAAKyG,EAAQC,KAAOnP,OAAOmD,QAAQkN,GAAc,CACpD,GAAIjQ,KAAKgP,sBAAsBF,EAAQrK,GACrC,SAEFsK,EAAK/O,KAAKiP,gBAAgBF,GAC1B,MAAM5M,EAAU,IAAKnC,KAAKkP,iBAAiBH,EAAIA,GAAII,gBAC7CC,EAAapP,KAAK8M,KAAKhL,SAAS,IAAKiN,EAAG5M,WAAYA,IACtD4M,EAAGvM,OAAO4M,EAAW5M,QACzBxC,KAAK4M,cAAcnJ,KAAK,CAAErE,KAAM0P,EAAQnJ,WAAYlB,EAAI3C,SAAUsN,IAClE,IAAK,MAAMC,KAAaN,EAAG/D,WAAY,CACrC,MAAMsE,EAAoBtP,KAAKuP,sBAAsBF,EAAW5K,GAChE2K,EAAWP,IAAIS,EAAmBD,EAAUpQ,YAAY6C,UAAU+H,UAAY,EAC/E,CACF,CACD7J,KAAKwP,kBAAkB/K,EAAI4D,EAAQ,IAGvCrI,KAAK4P,SApBW,CAqBjB,CAED,qBAAAZ,CAAuBF,EAAQnJ,GAC7B,OAAO3F,KAAK4M,cAAc1N,MAAK6P,GAAMA,EAAG3P,OAAS0P,GAAUC,EAAGpJ,aAAeA,GAC9E,CAED,iBAAA6J,CAAmB7J,EAAY0C,GAC7BrI,KAAKI,SAASN,SAAQ8E,IACpB,MAAM9F,QAAEA,EAAOG,WAAEA,EAAU4E,QAAEA,GAAYe,EACzC,GAAI3F,GAAYmD,KAAKuD,IAAe1G,GAAYoD,SAASsD,GAAa,CACpE,MAAMqE,EAAS/K,EAAWmD,GAAGuD,GAAYqE,OACnCkG,EAAajR,EAAWoD,OAAOsD,GACrCqE,EAAOlK,SAAQqQ,IACbtM,EAAQ/D,SAAQP,IACd,MAAM6Q,EAAWpC,IACfhO,KAAKqQ,aAAaH,EAAW7N,OAAQ6N,EAAW3Q,OAAQ2Q,EAAW7F,UAAW2D,EAAOrI,EAAW,EAElG0C,EAAQwG,KAAI,KACVtP,EAAO+Q,iBAAiBH,EAAWC,GAC5B,KACL7Q,EAAOgR,oBAAoBJ,EAAWC,EAAQ,IAEhD,GACF,GAEL,IAEJ,CAED,YAAAC,CAAcG,EAAYC,EAAcC,EAAY1C,EAAOrI,GACR,mBAAtC3F,KAAK+M,SAASe,QAAQ0C,GAC/BxQ,KAAK+M,SAASe,QAAQ0C,GAAYC,EAAczC,EAAO0C,EAAY/K,GACjB,mBAAlCnH,EAAGZ,OAAOkQ,QAAQ0C,GAClChS,EAAGZ,OAAOkQ,QAAQ0C,GAAYC,EAAczC,EAAO0C,EAAY/K,GAE/DnH,EAAGH,MAAMK,KAAK,WAAW8R,gBAE5B,CAED,iBAAAvC,CAAmB7O,EAAMuG,GACvB,MAAMgL,EAAgB3Q,KAAK4M,cAAcgE,MAAK7B,GAAMA,EAAG3P,OAASA,GAAQ2P,EAAGpJ,aAAeA,IAC1F,OAAOgL,EAAgBA,EAAc7O,SAAW,IACjD,CAED,OAAA8N,GACE5P,KAAK2L,QAAQ+C,eAAiB1O,KAAK2L,QAAQ+C,cAAc1C,SACzDhM,KAAK2L,QAAQ+C,eAAiB1O,KAAK2L,QAAQ+C,cAAcmC,SAAS/Q,SAAQgR,GAAWA,EAAQlB,WAC9F,CAED,UAAAD,GACE/G,OAAO0H,iBAAiB,QAAQ,IAAMtQ,KAAK4P,WAC5C,CAED,YAAAH,GACE7G,OAAO0H,iBAAiB,SAAU9R,EAAGI,MAAMmC,UAAS,IAAMf,KAAK4P,WAAW,KAAM,CAAEmB,SAAS,GAC5F,CAED,cAAArB,GACE9G,OAAO0H,iBAAiB,YAAatC,GAAUA,EAAMgD,WAAahR,KAAK4P,WAAa5P,KAAKyO,WAC1F,CAED,SAAAwC,CAAWlR,GACT,OAAOvB,EAAGZ,OAAOmC,IAAQC,KAAK+M,SAAShN,IAAQ,IAChD,CAED,gBAAAmP,CAAkBjQ,EAAYH,GAC5B,IAAKG,EAAWqD,OAAQ,MAAO,CAAE,EAEjC,MAAO,CAAE0K,cAAe,CAAE8D,QAAShS,KAD8B,IAA1Cc,OAAOC,KAAKZ,EAAWqD,QAAQ4C,OAAelF,KAAKiR,UAAU,iBAAmBhS,EAAWqD,QAEnH,CAED,YAAA4O,CAAcjS,EAAY4E,GACxB,IAAK5E,EAAWsD,UAAW,OAAOsB,EAClC,MAAMsN,EAAmBlS,EAAWsD,UAC9BmH,EAAQ,IAAI1J,KAAK2L,QAAQiD,UAAU/K,EAASsN,GAE5CC,GADaD,EAAiBzL,MAAQ,IACnBgE,MAAM,KAAKpG,KAAIqG,GAAKA,EAAE7E,SAC/C,IAAIuM,EAAmB,GAKvB,OAJID,EAAM/Q,SAAS,WAAUgR,EAAmBA,EAAiBC,OAAO5H,EAAM6H,QAC1EH,EAAM/Q,SAAS,WAAUgR,EAAmBA,EAAiBC,OAAO5H,EAAM8H,QAC1EJ,EAAM/Q,SAAS,WAAUgR,EAAmBA,EAAiBC,OAAO5H,EAAM+H,QAC9C,IAA5BJ,EAAiBnM,SAAcmM,EAAmBxN,GAC/CwN,CACR,CAED,eAAApC,CAAiBF,GACf,IAAI/B,EAAgB,KAChBxK,GAAQ,EAWZ,OAVAuM,EAAG/D,WAAWlL,SAAQuP,IAChBA,EAAUpQ,YAAYqD,SACxB0K,EAAiBA,GAAgB,CAAE1K,OAAQ+M,EAAUpQ,WAAWqD,QAAU0K,EAAemC,cAAeE,EAAUvQ,SAAWqQ,sBACtHE,EAAUpQ,WAAWqD,QAE1B+M,EAAUpQ,YAAYuD,QACxBA,EAASA,GAAQ,CAAEA,OAAO,UACnB6M,EAAUpQ,WAAWuD,MAC7B,IAEI,IAAKuM,KAAO/B,KAAkBxK,EACtC,CAED,qBAAA+M,CAAuBF,EAAW1J,GAChC,MAAM7G,QAAEA,EAAOG,WAAEA,EAAU4E,QAAEA,GAAYwL,EACzC,IAAIlN,EAAU,IAAKnC,KAAKkP,iBAAiBjQ,EAAYH,MAAakB,KAAKiR,UAAU,gBAC7EI,EAAmBrR,KAAKkR,aAAajS,EAAY4E,GACrD,OAAI5E,EAAWiD,UAAkBlC,KAAK8M,KAAK7K,GAAGoP,EAAkB,CAAEnP,UAAWjD,EAAWiD,aAAcjD,GAAYkD,WAAYA,IAC1HlD,EAAWD,OAASC,EAAWgD,GAAWjC,KAAK8M,KAAK9N,KAAKqS,EAAkB,IAAKpS,EAAWD,QAASC,GAAYkD,WAAYA,IAC5HlD,EAAWgD,KAAOhD,EAAWD,KAAagB,KAAK8M,KAAK7K,GAAGoP,EAAkB,IAAKpS,EAAWgD,MAAOhD,GAAYkD,WAAYA,IACxHlD,EAAWD,MAAQC,EAAWgD,GAAWjC,KAAK8M,KAAK4E,OAAOL,EAAkBpS,EAAWD,KAAM,IAAKC,EAAWgD,MAAOhD,GAAYkD,WAAYA,SAAhJ,CACD,CAED,kBAAAqM,GACE,IAAKxO,KAAKiR,UAAU,mBAAmB1D,QAAS,OAChDvN,KAAK2L,QAAQgG,eAAiB3R,KAAK2L,SAASgG,gBAAkBA,eAC9D3R,KAAK8M,KAAK6B,eAAe3O,KAAK2L,QAAQgG,gBACtBvO,SAASwO,cAAc,mBAKvC5R,KAAK2L,QAAQgG,eAAeE,OAAO,IAC9B7R,KAAKiR,UAAU,kBAAkB9O,QACpC2P,QAAS,kBACTC,QAAS,oBANTvT,EAAGH,MAAMM,MAAM,2CAQlB,CAED,OAAAqT,GACEhS,KAAK4M,cAAgB5M,KAAK4M,cAAcpI,QAAO,EAAG1C,WAAU1C,OAAMuG,kBACzC3F,KAAKI,SAASlB,MAAK+S,GACjCA,EAAOhT,WAAW6C,WAAW6D,IAAavG,OAASA,MAG1D0C,EAASoQ,QACF,IAIZ"}