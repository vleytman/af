{"version":3,"file":"af-gsap.umd.js","sources":["../src/af-core.js","../src/af-gsap.js"],"sourcesContent":["let Config = {\n  prefix: 'af-',\n  breakpoints: {\n    sm: '(max-width: 640px)',\n    md: '(min-width: 641px) and (max-width: 768px)',\n    lg: '(min-width: 769px) and (max-width: 1024px)',\n    xl: '(min-width: 1025px) and (max-width: 1280px)',\n    xxl: '(min-width: 1281px)',\n  },\n  engine: 'gsap',\n  debug: true,\n}\n\nlet AnimationEngine = {}\n\nconst debug = {\n  log: (...args) => { AF.Config.debug && console.log('[AF]', ...args) },\n  warn: (...args) => { AF.Config.debug && console.warn('[AF]', ...args) },\n  error: (...args) => { AF.Config.debug && console.error('[AF]', ...args) },\n}\n\nconst utils = {\n\n  deepMergeObjects (target, source) {\n    if (Array.isArray(target) && Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(target)) {\n      return source\n    } else if (typeof target === 'object' && typeof source === 'object' && target !== null && source !== null) {\n      const output = { ...target }\n      Object.keys(source).forEach(key => {\n        output[key] = this.deepMergeObjects(target[key], source[key])\n      })\n      return output\n    } else {\n      return source\n    }\n  },\n\n  mergeConfig (config) {\n    AF.Config = this.deepMergeObjects(AF.Config, config)\n    AF.Config.breakpoints = config.breakpoints ?? AF.Config.breakpoints\n  },\n\n  hasElementsWithAttributes (elements, attributes) {\n    return elements.some(element => attributes.some(attr => Object.keys(element.attributes).includes(attr)))\n  },\n\n  generateRandomName () {\n    return Math.random().toString(36).substring(2, 10)\n  },\n\n  kebabCase (str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n  },\n\n  debounce (func, wait) {\n    let timeout\n    return function executedFunction (...args) {\n      const later = () => {\n        clearTimeout(timeout)\n        func(...args)\n      }\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n    }\n  },\n\n  getBreakpointMaxWidth (query) {\n    const maxWidthMatch = query.match(/\\(max-width:\\s*(\\d+)px\\)/)\n    const minWidthMatch = query.match(/\\(min-width:\\s*(\\d+)px\\)/)\n    if (maxWidthMatch) {\n      return parseInt(maxWidthMatch[1])\n    } else if (minWidthMatch) {\n      return Infinity\n    }\n    return 0\n  },\n\n}\n\nconst Parser = {\n\n  parsers: {\n    timeline: { flow: ['disallowEmpty', 'parseTimelineValue'], responsive: true },\n    from: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    to: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    keyframes: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues', 'parseKeyframesValue'], responsive: true },\n    options: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    target: { flow: ['parseSelectorValue'], responsive: false },\n    on: { flow: ['disallowEmpty', 'parseOnValue'], responsive: true },\n    action: { flow: ['disallowEmpty', 'parseActionValue'], responsive: true },\n    scroll: { flow: ['parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    splittext: { flow: ['parseSplitTextValue'], responsive: true },\n    pause: { flow: ['parseEmptyValue'], responsive: true },\n  },\n\n  parseElements () {\n    const elements = Array.from(new Set([...this.getAnimatableElements(), ...this.getAnimatableElementsByPreset()]))\n    if (!elements) return\n    return this.processAttributes(elements)\n  },\n\n  getAnimatableElementsByPreset () {\n    if (!AF.Config.presets) return []\n    return Object.entries(AF.Config.presets).flatMap(([presetName, preset]) => {\n      const className = `${AF.Config.prefix}${utils.kebabCase(presetName)}`\n      return [...document.getElementsByClassName(className)].map(element => {\n        element.setAttribute(`${AF.Config.prefix}preset`, presetName)\n        return element\n      })\n    })\n  },\n\n  processAttributes (elements) {\n    if (!elements) return\n    let parsedElements = []\n    elements.forEach(element => {\n      try {\n        parsedElements.push(this.parseSingleElement(element))\n      } catch {\n        debug.error(`Can't parse element:`, element)\n        return parsedElements\n      }\n    })\n    parsedElements = this.propagateBreakpoints(parsedElements)\n    return parsedElements\n  },\n\n  parseSingleElement (element) {\n    const attributes = this.parseElementAttributes(element)\n    const targets = this.getTargets({ element, attributes })\n    return { element, attributes, targets }\n  },\n\n  propagateBreakpoints (data) {\n    const configBreakpoints = Object.keys(AF.Config.breakpoints).sort((a, b) => {\n      const aWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[a])\n      const bWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[b])\n      return bWidth - aWidth\n    })\n    return data.map(element => {\n      for (const [attrKey, attrValue] of Object.entries(element.attributes)) {\n        if (this.parsers[attrKey] && this.parsers[attrKey].responsive) {\n          const hasDefault = 'default' in attrValue\n          const presentBreakpoints = Object.keys(attrValue).filter(bp => bp !== 'default' && bp in AF.Config.breakpoints)\n          let propagatedValues = {}\n          if (hasDefault) {\n            propagatedValues = utils.deepMergeObjects({}, attrValue.default)\n          }\n          configBreakpoints.forEach(bp => {\n            if (bp in attrValue) {\n              propagatedValues = utils.deepMergeObjects(propagatedValues, attrValue[bp])\n            }\n            element.attributes[attrKey][bp] = utils.deepMergeObjects({}, propagatedValues)\n          })\n          if (hasDefault) {\n            delete element.attributes[attrKey].default\n          }\n        }\n      }\n      return element\n    })\n  },\n\n  getTargets (elementData) {\n    if (elementData.attributes?.target === '&' || !elementData.attributes?.target) return [elementData.element]\n    const targetSelector = elementData.attributes.target.trim()\n    const subSelector = targetSelector.slice(1).trim()\n    if (targetSelector.startsWith('&')) {\n      const matchedElements = this.getMatchedElements(elementData.element, subSelector)\n      return matchedElements.length ? matchedElements : [elementData.element]\n    }\n    return document.querySelectorAll(targetSelector)\n  },\n\n  getMatchedElements (element, subSelector) {\n    if (subSelector.match(/^([.#\\[])/) && element.matches(subSelector)) return [element]\n    if (subSelector.startsWith('>')) return [...element.children].filter(child => child.matches(subSelector.slice(1).trim()))\n    return [...element.querySelectorAll(subSelector)]\n  },\n\n  getAnimatableElements () {\n    const elements = Array.from(document.querySelectorAll('*'))\n    return elements.filter(element =>\n      Array.from(element.attributes).some(attr => attr.name.startsWith(AF.Config.prefix))\n    )\n  },\n\n  parseElementAttributes (element) {\n    let parsedAttributes = {}\n    let presetName = null\n    Array.from(element.attributes).forEach(attr => {\n      if (attr.name === `${AF.Config.prefix}preset`) {\n        presetName = attr.value.trim()\n        return\n      }\n      if (attr.name.startsWith(AF.Config.prefix)) {\n        const components = this.extractAttributeComponents(attr.name)\n        if (!components) return\n        const { type, breakpoint } = components\n        if (!this.parsers[type]) {\n          debug.warn(`Unknown attribute: ${attr.name}`)\n          return\n        }\n        let parsedData = this.runParsers(element, type, attr.value)\n        if (parsedData) {\n          parsedAttributes[type] = parsedAttributes[type] ?? {}\n          parsedAttributes[type][breakpoint] = parsedData\n          parsedAttributes[type] = this.checkIfResponsiveAttribute(parsedAttributes[type], type)\n        } else {\n          debug.warn(`Error parsing \"${type}\" attribute value: ${attr.value}`)\n        }\n      }\n    })\n    if (presetName) {\n      const presetAttributes = this.parsePresetAttributes(presetName, element)\n      this.deepMergeAttributes(parsedAttributes, presetAttributes)\n    }\n    return parsedAttributes\n  },\n\n  extractAttributeComponents (attrName) {\n    const attrUnprefixedName = attrName.slice(AF.Config.prefix.length)\n    const match = attrUnprefixedName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/)\n    if (match[2] && !AF.Config.breakpoints[match[2]]) {\n      debug.warn(`Invalid breakpoint: ${match[2]}`)\n      return null\n    }\n    return match ? { type: match[1], breakpoint: match[2] || 'default' } : null\n  },\n\n  runParsers (element, type, value) {\n    try {\n      let parsedData = {}\n      let lastValue = null\n      for (const parser of this.parsers[type].flow) {\n        parsedData = lastValue ? this[parser](lastValue, element) : this[parser](value, element)\n        lastValue = parsedData\n      }\n      return parsedData\n    } catch (error) {\n      return null\n    }\n  },\n\n  disallowEmpty (value, element) {\n    if (value === '') throw new Error(`Empty value for attribute is not allowed`)\n    return value\n  },\n\n  checkIfResponsiveAttribute (data, type) {\n    return !Parser.parsers[type].responsive ? data[Object.keys(data)[0]] : data\n  },\n\n  parsePresetAttributes (presetName, element) {\n    const preset = AF.Config.presets[presetName]\n    if (!preset) {\n      debug.warn(`Preset \"${presetName}\" not found`)\n      return {}\n    }\n    return Object.entries(preset).reduce((presetAttrs, [attrName, attrValue]) => {\n      if (attrName === 'selector') return presetAttrs\n      const [, type, breakpoint = 'default'] = attrName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/) || []\n      if (!type || !this.parsers[type]) {\n        debug.warn(`Invalid or unknown preset attribute: \"${attrName}\"`)\n        return presetAttrs\n      }\n      if (breakpoint !== 'default' && !AF.Config.breakpoints[breakpoint]) {\n        debug.warn(`Invalid breakpoint \"${breakpoint}\" in preset \"${presetName}\" for type \"${type}\"`)\n        return presetAttrs\n      }\n      let parsedData = this.runParsers(element, type, attrValue)\n      if (parsedData) {\n        presetAttrs[type] = { ...presetAttrs[type], [breakpoint]: parsedData }\n      } else {\n        debug.warn(`Error parsing \"${type}\" attribute value: ${attrValue}`)\n      }\n      return presetAttrs\n    }, {})\n  },\n\n  parseObjectAttribute (value, element) {\n    if (typeof value === 'object') return value // Already parsed\n    value = this.resolveVariables(value, element) // Resolve variables\n    value = this.escapeCommas(value) // Escape commas inside brackets\n    value = value.replace(/'/g, '\"') // Single quotes => double quotes\n      .replace(/\\s+/g, ' ').trim() // Normalize whitespace\n      .replace(/(^|[,{]\\s*)([^\\s,\"'{}[\\]:]+)(\\s*:)/g, '$1\"$2\"$3') // Quote keys (including at the start of the string)\n      .replace(/(:\\s*)([^,{}\\[\\]\\s][^,{}\\[\\]]*)(?=[,}\\]]|$)/g, (match, p1, p2) => { // Quote values, skipping arrays and objects\n        const trimmedValue = p2.trim()\n        if (trimmedValue.startsWith('[') || trimmedValue.startsWith('{')) return `${p1}${trimmedValue}` // Skip arrays and objects\n        if (/^-?\\d+(\\.\\d+)?$/.test(trimmedValue) || /^(true|false|null)$/i.test(trimmedValue)) return `${p1}${trimmedValue}` // Do not quote numbers, booleans, null\n        if (!/^\".*\"$/.test(trimmedValue)) return `${p1}\"${trimmedValue}\"` // Quote if not already quoted\n        return match\n      })\n      .replace(/__COMMA__/g, ',')\n\n    return value\n  },\n\n  escapeCommas (str) {\n    let result = ''\n    let depth = 0\n    let inQuote = false\n    let quoteChar = ''\n    const brackets = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    }\n    const stack = []\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i]\n\n      if (inQuote) {\n        result += c\n        if (c === quoteChar) {\n          inQuote = false\n        }\n      } else if (c === '\"' || c === '\\'') {\n        inQuote = true\n        quoteChar = c\n        result += c\n      } else if (brackets[c]) {\n        stack.push(brackets[c])\n        depth++\n        result += c\n      } else if (stack.length > 0 && c === stack[stack.length - 1]) {\n        stack.pop()\n        depth--\n        result += c\n      } else if (c === ',' && depth > 0) {\n        result += '__COMMA__'\n      } else {\n        result += c\n      }\n    }\n    return result\n  },\n\n  deepMergeAttributes (target, source) {\n    for (const [type, typeData] of Object.entries(source)) {\n      if (!target[type]) {\n        target[type] = utils.deepMergeObjects({}, typeData)\n        continue\n      }\n      for (const [breakpoint, value] of Object.entries(typeData)) {\n        if (!target[type][breakpoint]) {\n          target[type][breakpoint] = value\n        } else {\n          target[type][breakpoint] = utils.deepMergeObjects(target[type][breakpoint], value)\n        }\n      }\n    }\n  },\n\n  resolveVariables (str, element) {\n    let resolvedStr = str.replace(/var\\((--[^)]+)\\)/g, (match, varName) => {\n      const computedValue = getComputedStyle(element).getPropertyValue(varName).trim()\n      return computedValue || 'undefined'\n    })\n    resolvedStr = resolvedStr.replace(/\\${([^}]+)}/g, (_, p1) => this.evaluateExpression(p1.trim(), this.getElementContext(element)))\n    return resolvedStr\n  },\n\n  evaluateExpression: (() => {\n    const cache = new Map()\n    return (expression, context) => {\n      if (!cache.has(expression)) cache.set(expression, new Function('\"use strict\";return (' + expression + ')'))\n      try {\n        return cache.get(expression).call(context)\n      } catch (error) {\n        debug.error(`Error evaluating expression: ${expression}`, error)\n        return undefined\n      }\n    }\n  })(),\n\n  getElementContext (element) {\n    return {\n      $element: element,\n      window,\n      document,\n    }\n  },\n\n  parseJsonToObjectOrArray (value, element) {\n    if (typeof value === 'object') return value\n    try {\n      return JSON.parse(`{${value}}`)\n    } catch (error1) {\n      try {\n        return JSON.parse(`[${value}]`)\n      } catch (error2) {\n        debug.error('Error parsing attribute value:', value, error2)\n        return null\n      }\n    }\n  },\n\n  normalizeAttributeValues (data, depth = 0, maxDepth = 100) {\n    if (depth > maxDepth) {\n      AF.debug.error('Maximum recursion depth exceeded in normalizeAttributeValues')\n      return data\n    }\n    if (Array.isArray(data)) {\n      return data.map(value => this.normalizeAttributeValues(value, depth + 1, maxDepth))\n    }\n    if (data !== null && typeof data === 'object') {\n      return Object.fromEntries(\n        Object.entries(data).map(([key, value]) => [key, this.normalizeAttributeValues(value, depth + 1, maxDepth)])\n      )\n    }\n    return this.normalizeValue(data)\n  },\n\n  normalizeValue (value) {\n    if (typeof value === 'number') return value\n    if (typeof value !== 'string') return value\n    const trimmed = value.trim()\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) return Number(trimmed)\n    if (/^(true|false)$/i.test(trimmed)) return trimmed.toLowerCase() === 'true'\n    return value\n  },\n\n  parseTimelineValue (value) {\n    const parts = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (parts.length > 3) throw new Error(`Invalid timeline value: ${value}. Expected format: name[, position][, properties]`)\n    return parts.length === 1 ? { name: String(parts[0]), position: null } : parts.length === 2 ? { name: parts[0], position: this.normalizeValue(parts[1]) } : {\n      name: parts[0],\n      position: this.normalizeValue(parts[1]),\n      options: this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(parts[2], null), null))[0]\n    }\n  },\n\n  parseSelectorValue (value, element) {\n    return value.trim()\n  },\n\n  parseOnValue (value, element) {\n    const parts = value.split(',').map(s => s.trim())\n    return { events: parts }\n  },\n\n  parseActionValue (value, element) {\n    const [action, target, ...argParts] = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (!target || !action) {\n      throw new Error(`Invalid action format: \"${value}\", needs at least target and action.`)\n    }\n    const argStr = argParts.join(',').trim()\n    const args = argStr ? argStr.startsWith('{') && argStr.endsWith('}')\n      ? this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(argStr, element), element))\n      : this.normalizeValue(argStr) : {}\n    return {\n      action, target,\n      arguments: args\n    }\n  },\n\n  parseKeyframesValue (value, element) {\n    return value\n  },\n\n  parseSplitTextValue (value, element) {\n    if (typeof value === 'object') return value\n    if (value.includes(':')) {\n      value = this.parseObjectAttribute(value, element)\n      value = this.parseJsonToObjectOrArray(value, element)\n      value = this.normalizeAttributeValues(value)\n      return value\n    }\n    const types = value.split(',').map(s => s.trim()).filter(s => s.length > 0)\n    return { type: types.join(', ') }\n  },\n\n  parseEmptyValue (value, element) {\n    return true\n  },\n\n  getTimelines (elements) {\n    const timelines = {}\n    const processBreakpoint = (item, bp) => {\n      const { attributes, element, targets } = item\n      const timelineName = attributes.timeline?.[bp]?.name ?? attributes.timeline?.default?.name ?? (element.id.length ? element.id : null) ?? utils.generateRandomName()\n      timelines[bp] ??= {}\n      timelines[bp][timelineName] ??= { animations: [], options: {} }\n      const bpAttrs = Object.fromEntries(\n        Object.entries(attributes)\n          .filter(([, value]) => value[bp] || (value.default && bp === 'default'))\n          .map(([key, value]) => [key, value[bp] ?? value.default])\n      )\n      timelines[bp][timelineName].animations.push({ element, attributes: bpAttrs, targets })\n      if (Object.keys(timelines[bp][timelineName].options).length === 0) {\n        timelines[bp][timelineName].options = this.getTimelineOptions(attributes.timeline)\n      }\n    }\n    elements.forEach(item => {\n      const usedBreakpoints = new Set(Object.values(item.attributes).flatMap(attr => Object.keys(attr)))\n      if (usedBreakpoints.has('default')) {\n        usedBreakpoints.delete('default')\n        processBreakpoint(item, 'default')\n      }\n      usedBreakpoints.forEach(bp => processBreakpoint(item, bp))\n    })\n    return Object.fromEntries(Object.entries(timelines).filter(([key]) => isNaN(key)))\n  },\n\n  getTimelineOptions (timeline) {\n    if (!timeline) return {}\n    for (const key in timeline) {\n      if (timeline[key] && timeline[key].options) return timeline[key].options\n    }\n    return {}\n  },\n\n}\n\nconst AF = {\n\n  debug,\n  utils,\n  Parser,\n  Config,\n  engines: {},\n\n  registerEngine (name, engineClass, plugins) {\n    AF.engines[name] = {}\n    AF.engines[name].engineClass = engineClass\n    AF.engines[name].plugins = plugins\n  },\n\n  init (config = null) {\n    if (!AF.engines) return\n    if (config) AF.utils.mergeConfig(config)\n    const elements = Parser.parseElements()\n    const timelines = Parser.getTimelines(elements)\n    const EngineClass = AF.engines[Config.engine].engineClass\n    if (!EngineClass) {\n      this.debug.error(`Incorrect animation engine: ${AF.Config.engine}`)\n      return\n    }\n    const animationEngine = new EngineClass(elements, timelines)\n    if (animationEngine.init && typeof animationEngine.init === 'function') {\n      animationEngine.init(AF.Config)\n    }\n  },\n\n}\n\nexport default AF","import AF from './af-core.js'\n\nclass AFEngineGSAP {\n  gsapTimelines = []\n  elements = []\n  timelines = {}\n  matchMedia = null\n  gsap = null\n  plugins = null\n  handlersSet = false\n\n  defaults = {\n    scrollTrigger: {\n      start: 'top 90%',\n      end: 'bottom 10%',\n      toggleActions: 'play reverse play reverse',\n      scrub: false,\n      invalidateOnRefresh: true,\n    },\n    scrollSmoother: {\n      enabled: false,\n      options: {\n        smooth: 1,\n        effects: true,\n        smoothTouch: 0.1,\n      },\n    },\n    allDefaults: {\n      force3D: true,\n      lazy: false,\n    },\n    actions: {},\n  }\n\n  constructor (elements, timelines) {\n    this.elements = elements\n    this.timelines = timelines\n    this.defaults.actions = {\n      play: this.createTimelineAction('play'),\n      pause: this.createTimelineAction('pause'),\n      restart: this.createTimelineAction('restart'),\n      reverse: this.createTimelineAction('reverse'),\n      toggle: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          timeline.reversed() ? timeline.play() : timeline.reverse()\n        }\n      },\n    }\n  }\n\n  createTimelineAction (methodName) {\n    return (target, event, args, breakpoint) => {\n      const timeline = this.getTimelineByName(target, breakpoint)\n      if (timeline && typeof timeline[methodName] === 'function') timeline[methodName]()\n    }\n  }\n\n  init (config) {\n    AF.Config = config\n    if (!AF.Config?.plugins?.gsap && !window.gsap) {\n      AF.debug.error('GSAP core not found')\n      return\n    }\n    this.gsap = AF.Config?.plugins?.gsap || window.gsap\n    this.plugins = AF.Config?.plugins || {}\n    this.loadRequiredPlugins(this.elements)\n    this.initScrollSmoother()\n    this.matchMedia = this.gsap.matchMedia()\n    this.animate()\n    this.initMutationObserver()\n  }\n\n  loadRequiredPlugins (elements) {\n    const pluginMap = {\n      scroll: 'ScrollTrigger',\n      splittext: 'SplitText',\n    }\n\n    for (const [attr, pluginName] of Object.entries(pluginMap)) {\n      if (AF.utils.hasElementsWithAttributes(elements, [attr])) {\n        this.plugins[pluginName] = this.plugins?.[pluginName] || window[pluginName]\n        this.gsap.registerPlugin(this.plugins[pluginName])\n      }\n    }\n  }\n\n  animate () {\n    if (!this.timelines) return\n    this.cleanupContexts()\n    this.contexts = []\n    for (const [bp, timelines] of Object.entries(this.timelines)) {\n      const context = this.matchMedia.add(AF.Config.breakpoints[bp], () => {\n        for (let [tlName, tl] of Object.entries(timelines)) {\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: bp, timeline: tlInstance })\n          tl.animations.forEach(animation => {\n            const animationInstance = this.createSingleAnimation(animation)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          })\n        }\n        this.plugins.ScrollTrigger?.refresh()\n      })\n      this.contexts.push(context)\n      this.setupEventActions(bp, context)\n    }\n    this.handleResize()\n    this.handlePageShow()\n    this.handleLoad()\n    this.handlersSet = true\n  }\n\n  cleanupContexts () {\n    this.contexts?.forEach(context => context.revert())\n    this.contexts = []\n  }\n\n  setupEventActions (breakpoint, context) {\n    this.elements.forEach(({ attributes, targets }) => {\n      const onAttrs = attributes?.on?.[breakpoint]\n      const actionAttrs = attributes?.action?.[breakpoint]\n      if (onAttrs && actionAttrs) {\n        const events = onAttrs.events\n        events.forEach(eventName => {\n          targets.forEach(target => {\n            const handler = event => {\n              this.handleAction(actionAttrs.action, actionAttrs.target, actionAttrs.arguments, event, breakpoint)\n            }\n            context.add(() => {\n              target.addEventListener(eventName, handler)\n              return () => target.removeEventListener(eventName, handler)\n            })\n          })\n        })\n      }\n    })\n  }\n\n  handleAction (actionName, actionTarget, actionArgs, event, breakpoint) {\n    const action = this.defaults.actions[actionName] || AF.Config.actions?.[actionName]\n    if (typeof action === 'function') return action(actionTarget, event, actionArgs, breakpoint)\n    AF.debug.warn(`Action \"${actionName}\" not found.`)\n  }\n\n  getTimelineByName (name, breakpoint) {\n    return this.gsapTimelines.find(tl => tl.name === name && tl.breakpoint === breakpoint)?.timeline || null\n  }\n\n  refresh () {\n    window.scrollTo(0, 0)\n    this.gsapTimelines.forEach(tl => tl.timeline.restart())\n    this.plugins.ScrollTrigger?.update()\n    this.plugins.ScrollTrigger?.refresh()\n    this.plugins.ScrollTrigger?.getAll().forEach(trigger => {\n      trigger.update()\n      trigger.refresh()\n    })\n  }\n\n  handleLoad () {\n    if (this.handlersSet) return\n    window.addEventListener('load', () => this.refresh())\n  }\n\n  handleResize () {\n    if (this.handlersSet) return\n    window.addEventListener('resize', AF.utils.debounce(() => this.reinitializeAnimations(), 100), { passive: true })\n  }\n\n  handlePageShow () {\n    if (this.handlersSet) return\n    window.addEventListener('pageshow', event => event.persisted && (this.refresh(), this.animate()))\n  }\n\n  getConfig (key) {\n    return AF.Config[key] ?? this.defaults[key] ?? null\n  }\n\n  getScrollTrigger (attributes, element) {\n    const scrollAttrs = attributes.scroll\n    if (!scrollAttrs) return {}\n    const scrollOptions = Object.keys(scrollAttrs).length ? scrollAttrs : this.getConfig('scrollTrigger')\n    return { scrollTrigger: { trigger: element, ...scrollOptions } }\n  }\n\n  getSplitText (attributes, targets) {\n    const splittext = attributes.splittext\n    if (!splittext) return targets\n    const split = new this.plugins.SplitText(targets, splittext)\n    const types = (splittext.type || '').split(',').map(s => s.trim())\n    const typeMap = { chars: split.chars, words: split.words, lines: split.lines }\n    const animationTargets = types.reduce((acc, type) => acc.concat(typeMap[type] || []), [])\n    return animationTargets.length ? animationTargets : targets\n  }\n\n  prepareTimeline (tl) {\n    let scrollTrigger = null\n    let pause = false\n    for (const animation of tl.animations) {\n      const { attributes } = animation\n      if (attributes?.scroll && !scrollTrigger) {\n        scrollTrigger = { scroll: attributes.scroll, scrollElement: animation.element }\n        delete attributes.scroll\n      }\n      if (attributes?.pause && !pause) {\n        pause = true\n        delete attributes.pause\n      }\n    }\n    return { ...tl, ...scrollTrigger, pause }\n  }\n\n  createSingleAnimation (animation) {\n    const { element, attributes, targets } = animation\n    const options = { ...this.getConfig('allDefaults') }\n    const animationTargets = this.getSplitText(attributes, targets)\n    if (attributes.scroll) {\n      options.scrollTrigger = { trigger: element, ...attributes.scroll }\n    }\n    const { from, to, keyframes } = attributes\n    const method = keyframes ? 'to' : from && to ? 'fromTo' : from ? 'from' : 'to'\n    const tweenOptions = { ...attributes.options, ...options }\n    switch (method) {\n      case 'to':\n        return this.gsap.to(animationTargets, { ...(keyframes ? { keyframes } : to), ...tweenOptions })\n      case 'from':\n        return this.gsap.from(animationTargets, { ...from, ...tweenOptions })\n      case 'fromTo':\n        return this.gsap.fromTo(animationTargets, from, { ...to, ...tweenOptions })\n    }\n  }\n\n  initScrollSmoother () {\n    const scrollSmootherConfig = this.getConfig('scrollSmoother')\n    if (!scrollSmootherConfig?.enabled) return\n    this.plugins.ScrollSmoother = this.plugins?.ScrollSmoother || window.ScrollSmoother\n    this.gsap.registerPlugin(this.plugins.ScrollSmoother)\n    const content = document.querySelector('#smooth-content')\n    if (!content) {\n      AF.debug.error('ScrollSmoother: No #smooth-content found')\n      return\n    }\n    this.plugins.ScrollSmoother.create({\n      ...scrollSmootherConfig.options,\n      wrapper: '#smooth-wrapper',\n      content: '#smooth-content',\n    })\n  }\n\n  initMutationObserver () {\n    const observerCallback = mutationsList => {\n      const addedElements = []\n      const removedElements = []\n      mutationsList.forEach(mutation => {\n        if (mutation.type === 'childList') {\n          ['addedNodes', 'removedNodes'].forEach(action => {\n            mutation[action].forEach(node => {\n              if (node.nodeType === Node.ELEMENT_NODE) {\n                const elements = this.getAnimatableElements(node)\n                if (elements.length) {\n                  (action === 'addedNodes' ? addedElements : removedElements).push(...elements)\n                }\n              }\n            })\n          })\n        }\n      })\n      if (addedElements.length) this.initializeAnimationsForElements(addedElements)\n      if (removedElements.length) this.cleanupAnimationsForElements(removedElements)\n    }\n    this.mutationObserver = new MutationObserver(observerCallback)\n    this.mutationObserver.observe(document.body, { childList: true, subtree: true, attributes: true })\n  }\n\n  initializeAnimationsForElements (elements) {\n    requestAnimationFrame(() => {\n      elements.forEach(el => el.offsetHeight)\n      const parsedElements = AF.Parser.processAttributes(elements)\n      const newTimelines = AF.Parser.getTimelines(parsedElements)\n      const currentBreakpoint = Object.entries(AF.Config.breakpoints).find(([_, query]) =>\n        window.matchMedia(query).matches\n      )?.[0]\n      if (!currentBreakpoint) {\n        AF.debug.warn('No matching breakpoint found for current viewport')\n        return\n      }\n      const timelines = newTimelines[currentBreakpoint] || newTimelines['default']\n      if (timelines) {\n        for (let [tlName, tl] of Object.entries(timelines)) {\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: currentBreakpoint, timeline: tlInstance })\n          tl.animations.forEach(animation => {\n            const animationInstance = this.createSingleAnimation(animation)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          })\n        }\n        this.plugins.ScrollTrigger?.refresh(true)\n      } else {\n        AF.debug.warn(`No timelines found for current breakpoint: ${currentBreakpoint}`)\n      }\n    })\n  }\n\n  getAnimatableElements (node) {\n    const elements = this.isAnimatableElement(node) ? [node] : []\n    elements.push(\n      ...node.querySelectorAll(\n        `[${AF.Config.prefix}from], [${AF.Config.prefix}to], [${AF.Config.prefix}keyframes]`\n      )\n    )\n    return elements\n  }\n\n  isAnimatableElement (element) {\n    return element.attributes && [...element.attributes].some(attr => attr.name.startsWith(AF.Config.prefix))\n  }\n\n  cleanupAnimationsForElements (elements) {\n    if (!elements?.length) return\n    elements.forEach(element => {\n      this.gsapTimelines = this.gsapTimelines.filter(({ timeline }) => {\n        const hasElement = timeline.getChildren().some(tween => tween.targets().includes(element))\n        if (hasElement) {\n          timeline.kill()\n          return false\n        }\n        return true\n      })\n    })\n    this.plugins.ScrollTrigger?.refresh()\n  }\n\n  reinitializeAnimations () {\n    this.cleanup()\n    this.elements = AF.Parser.parseElements()\n    this.timelines = AF.Parser.getTimelines(this.elements)\n    this.animate()\n    this.initMutationObserver()\n  }\n\n  cleanup () {\n    this.cleanupContexts()\n    this.gsapTimelines.forEach(({ timeline }) => timeline.kill())\n    this.gsapTimelines = []\n    this.plugins.ScrollTrigger?.getAll().forEach(trigger => trigger.kill())\n    this.mutationObserver?.disconnect()\n    this.mutationObserver = null\n  }\n}\n\nAF.registerEngine('gsap', AFEngineGSAP)\n\nexport default AF"],"names":["Config","prefix","breakpoints","sm","md","lg","xl","xxl","engine","debug","log","args","AF","console","warn","error","utils","deepMergeObjects","target","source","Array","isArray","slice","output","Object","keys","forEach","key","this","mergeConfig","config","hasElementsWithAttributes","elements","attributes","some","element","attr","includes","generateRandomName","Math","random","toString","substring","kebabCase","str","replace","toLowerCase","debounce","func","wait","timeout","clearTimeout","setTimeout","getBreakpointMaxWidth","query","maxWidthMatch","match","minWidthMatch","parseInt","Infinity","Parser","parsers","timeline","flow","responsive","from","to","keyframes","options","on","action","scroll","splittext","pause","parseElements","Set","getAnimatableElements","getAnimatableElementsByPreset","processAttributes","presets","entries","flatMap","presetName","preset","className","document","getElementsByClassName","map","setAttribute","parsedElements","push","parseSingleElement","propagateBreakpoints","parseElementAttributes","targets","getTargets","data","configBreakpoints","sort","a","b","aWidth","attrKey","attrValue","hasDefault","filter","bp","propagatedValues","default","elementData","targetSelector","trim","subSelector","startsWith","matchedElements","getMatchedElements","length","querySelectorAll","matches","children","child","name","parsedAttributes","components","extractAttributeComponents","type","breakpoint","parsedData","runParsers","value","checkIfResponsiveAttribute","presetAttributes","parsePresetAttributes","deepMergeAttributes","attrName","lastValue","parser","disallowEmpty","Error","reduce","presetAttrs","parseObjectAttribute","resolveVariables","escapeCommas","p1","p2","trimmedValue","test","result","depth","inQuote","quoteChar","brackets","stack","i","c","pop","typeData","resolvedStr","varName","getComputedStyle","getPropertyValue","_","evaluateExpression","getElementContext","cache","Map","expression","context","has","set","Function","get","call","$element","window","parseJsonToObjectOrArray","JSON","parse","error1","error2","normalizeAttributeValues","maxDepth","fromEntries","normalizeValue","trimmed","Number","parseTimelineValue","parts","split","s","String","position","parseSelectorValue","parseOnValue","events","parseActionValue","argParts","argStr","join","arguments","endsWith","parseKeyframesValue","parseSplitTextValue","parseEmptyValue","getTimelines","timelines","processBreakpoint","item","timelineName","id","animations","bpAttrs","getTimelineOptions","usedBreakpoints","values","delete","isNaN","engines","registerEngine","engineClass","plugins","init","EngineClass","animationEngine","gsapTimelines","matchMedia","gsap","handlersSet","defaults","scrollTrigger","start","end","toggleActions","scrub","invalidateOnRefresh","scrollSmoother","enabled","smooth","effects","smoothTouch","allDefaults","force3D","lazy","actions","constructor","play","createTimelineAction","restart","reverse","toggle","event","getTimelineByName","reversed","methodName","loadRequiredPlugins","initScrollSmoother","animate","initMutationObserver","pluginMap","pluginName","registerPlugin","cleanupContexts","contexts","add","tlName","tl","prepareTimeline","getScrollTrigger","scrollElement","tlInstance","animation","animationInstance","createSingleAnimation","ScrollTrigger","refresh","setupEventActions","handleResize","handlePageShow","handleLoad","revert","onAttrs","actionAttrs","eventName","handler","handleAction","addEventListener","removeEventListener","actionName","actionTarget","actionArgs","find","scrollTo","update","getAll","trigger","reinitializeAnimations","passive","persisted","getConfig","scrollAttrs","getSplitText","SplitText","types","typeMap","chars","words","lines","animationTargets","acc","concat","method","tweenOptions","fromTo","scrollSmootherConfig","ScrollSmoother","querySelector","create","wrapper","content","mutationObserver","MutationObserver","mutationsList","addedElements","removedElements","mutation","node","nodeType","Node","ELEMENT_NODE","initializeAnimationsForElements","cleanupAnimationsForElements","observe","body","childList","subtree","requestAnimationFrame","el","offsetHeight","newTimelines","currentBreakpoint","isAnimatableElement","getChildren","tween","kill","cleanup","disconnect"],"mappings":"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"}