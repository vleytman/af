{"version":3,"file":"af-gsap.umd.js","sources":["../src/af-gsap.js"],"sourcesContent":["import AF from './af-core.js'\n\nclass AFEngineGSAP {\n\n  gsapTimelines = []\n  elements = []\n  timelines = {}\n  matchMedia = null\n  gsap = null\n  plugins = null\n\n  defaults = {\n    scrollTrigger: {\n      start: 'top 90%',\n      end: 'bottom 10%',\n      toggleActions: 'play reverse play reverse',\n      scrub: false,\n      invalidateOnRefresh: true\n    },\n    scrollSmoother: {\n      enabled: false,\n      options: {\n        smooth: 1,\n        effects: true,\n        smoothTouch: 0.1,\n      }\n    },\n    allDefaults: {\n      force3D: true,\n      lazy: false,\n    },\n    actions: {\n      play: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          timeline.play()\n        }\n      },\n      pause: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.pause()\n      },\n      restart: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.restart()\n      },\n      reverse: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) timeline.reverse()\n      },\n      toggle: (target, event, args, breakpoint) => {\n        const timeline = this.getTimelineByName(target, breakpoint)\n        if (timeline) {\n          if (!timeline.reversed()) {\n            timeline.reverse()\n          } else {\n            timeline.play()\n          }\n        }\n      },\n    },\n  }\n\n  constructor (elements, timelines) {\n    this.elements = elements\n    this.timelines = timelines\n  }\n\n  init (settings, config) {\n    AF.Config = config\n    if (!settings?.plugins?.gsap && !window.gsap) {\n      AF.debug.error('GSAP core not found')\n      return\n    }\n    this.gsap = settings?.plugins?.gsap || window.gsap\n    this.plugins = settings?.plugins || {}\n    this.loadRequiredPlugins(this.elements)\n    this.initScrollSmoother()\n    this.matchMedia = this.gsap.matchMedia()\n    this.animate()\n  }\n\n  loadRequiredPlugins (elements) {\n    if (AF.utils.hasElementsWithAttributes(elements, ['scroll'])) {\n      this.plugins.ScrollTrigger = this.plugins?.ScrollTrigger || ScrollTrigger\n      this.gsap.registerPlugin(this.plugins.ScrollTrigger)\n    }\n    if (AF.utils.hasElementsWithAttributes(elements, ['splittext'])) {\n      this.plugins.SplitText = this.plugins?.SplitText || SplitText\n      this.gsap.registerPlugin(this.plugins.SplitText)\n    }\n  }\n\n  animate () {\n    if (!this.timelines) return\n    this.cleanup()\n    for (const [bp, timelines] of Object.entries(this.timelines)) {\n      this.matchMedia.add(AF.Config.breakpoints[bp], (context) => {\n        for (let [tlName, tl] of Object.entries(timelines)) {\n          tl = this.prepareTimeline(tl)\n          const options = { ...this.getScrollTrigger(tl, tl?.scrollElement) }\n          const tlInstance = this.gsap.timeline({ ...tl.options, ...options })\n          if (tl.pause) tlInstance.pause()\n          this.gsapTimelines.push({ name: tlName, breakpoint: bp, timeline: tlInstance })\n          for (const animation of tl.animations) {\n            const animationInstance = this.createSingleAnimation(animation, bp)\n            tlInstance.add(animationInstance, animation.attributes?.timeline?.position ?? 0)\n          }\n        }\n        this.setupEventActions(bp, context)\n      })\n    }\n    this.handleResize()\n    this.handlePageShow()\n    this.handleLoad()\n    this.refresh()\n  }\n\n  setupEventActions (breakpoint, context) {\n    this.elements.forEach(elementData => {\n      const { element, attributes, targets } = elementData\n      if (attributes?.on?.[breakpoint] && attributes?.action?.[breakpoint]) {\n        const events = attributes.on[breakpoint].events\n        const actionData = attributes.action[breakpoint]\n        events.forEach(eventName => {\n          targets.forEach(target => {\n            const handler = (event) => {\n              this.handleAction(actionData.action, actionData.target, actionData.arguments, event, breakpoint)\n            }\n            context.add(() => {\n              target.addEventListener(eventName, handler)\n              return () => {\n                target.removeEventListener(eventName, handler)\n              }\n            })\n          })\n        })\n      }\n    })\n  }\n\n  handleAction (actionName, actionTarget, actionArgs, event, breakpoint) {\n    if (typeof this.defaults.actions[actionName] === 'function') {\n      this.defaults.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else if (typeof AF.Config.actions[actionName] === 'function') {\n      AF.Config.actions[actionName](actionTarget, event, actionArgs, breakpoint)\n    } else {\n      AF.debug.warn(`Action \"${actionName}\" not found.`)\n    }\n  }\n\n  getTimelineByName (name, breakpoint) {\n    const timelineEntry = this.gsapTimelines.find(tl => tl.name === name && tl.breakpoint === breakpoint)\n    return timelineEntry ? timelineEntry.timeline : null\n  }\n\n  refresh () {\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.update()\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.getAll().forEach(trigger => trigger.refresh())\n  }\n\n  handleLoad () {\n    window.addEventListener('load', () => this.refresh())\n  }\n\n  handleResize () {\n    window.addEventListener('resize', AF.utils.debounce(() => this.refresh(), 200), { passive: true })\n  }\n\n  handlePageShow () {\n    window.addEventListener('pageshow', (event) => event.persisted && this.refresh() && this.animate())\n  }\n\n  getConfig (key) {\n    return AF.Config[key] ?? this.defaults[key] ?? null\n  }\n\n  getScrollTrigger (attributes, element) {\n    if (!attributes.scroll) return {}\n    let scrollAttributes = Object.keys(attributes.scroll).length === 0 ? this.getConfig('scrollTrigger') : attributes.scroll\n    return { scrollTrigger: { trigger: element, ...scrollAttributes } }\n  }\n\n  getSplitText (attributes, targets) {\n    if (!attributes.splittext) return targets\n    const splitTextOptions = attributes.splittext\n    const split = new this.plugins.SplitText(targets, splitTextOptions)\n    const typeString = splitTextOptions.type || ''\n    const types = typeString.split(',').map(s => s.trim())\n    let animationTargets = []\n    if (types.includes('chars')) animationTargets = animationTargets.concat(split.chars)\n    if (types.includes('words')) animationTargets = animationTargets.concat(split.words)\n    if (types.includes('lines')) animationTargets = animationTargets.concat(split.lines)\n    if (animationTargets.length === 0) animationTargets = targets\n    return animationTargets\n  }\n\n  prepareTimeline (tl) {\n    let scrollTrigger = null\n    let pause = false\n    tl.animations.forEach(animation => {\n      if (animation.attributes?.scroll) {\n        scrollTrigger = !scrollTrigger ? { scroll: animation.attributes.scroll ?? scrollTrigger, scrollElement: animation.element ?? scrollElement } : scrollTrigger\n        delete animation.attributes.scroll\n      }\n      if (animation.attributes?.pause) {\n        pause = !pause ? { pause: true } : pause\n        delete animation.attributes.pause\n      }\n    })\n    return { ...tl, ...scrollTrigger, ...pause }\n  }\n\n  createSingleAnimation (animation, breakpoint) {\n    const { element, attributes, targets } = animation\n    let options = { ...this.getScrollTrigger(attributes, element), ...this.getConfig('allDefaults') }\n    let animationTargets = this.getSplitText(attributes, targets)\n    if (attributes.keyframes) return this.gsap.to(animationTargets, { keyframes: attributes.keyframes, ...attributes?.options, ...options })\n    if (attributes.from && !attributes.to) return this.gsap.from(animationTargets, { ...attributes.from, ...attributes?.options, ...options })\n    if (attributes.to && !attributes.from) return this.gsap.to(animationTargets, { ...attributes.to, ...attributes?.options, ...options })\n    if (attributes.from && attributes.to) return this.gsap.fromTo(animationTargets, attributes.from, { ...attributes.to, ...attributes?.options, ...options })\n  }\n\n  initScrollSmoother () {\n    if (!this.getConfig('scrollSmoother')?.enabled) return\n    this.plugins.ScrollSmoother = this.plugins?.ScrollSmoother || ScrollSmoother\n    this.gsap.registerPlugin(this.plugins.ScrollSmoother)\n    const content = document.querySelector('#smooth-content')\n    if (!content) {\n      AF.debug.error('ScrollSmoother: No #smooth-content found')\n      return\n    }\n    this.plugins.ScrollSmoother.create({\n      ...this.getConfig('scrollSmoother').options,\n      wrapper: '#smooth-wrapper',\n      content: '#smooth-content',\n    })\n  }\n\n  cleanup () {\n    this.plugins.ScrollTrigger && this.plugins.ScrollTrigger.killAll()\n    if (this.gsapTimelines) {\n      this.gsapTimelines.forEach(({ timeline }) => timeline.kill())\n      this.gsapTimelines = []\n    }\n  }\n\n}\n\nexport default AFEngineGSAP"],"names":["gsapTimelines","elements","timelines","matchMedia","gsap","plugins","defaults","scrollTrigger","start","end","toggleActions","scrub","invalidateOnRefresh","scrollSmoother","enabled","options","smooth","effects","smoothTouch","allDefaults","force3D","lazy","actions","play","target","event","args","breakpoint","timeline","this","getTimelineByName","pause","restart","reverse","toggle","reversed","constructor","init","settings","config","AF","Config","window","loadRequiredPlugins","initScrollSmoother","animate","debug","error","utils","hasElementsWithAttributes","ScrollTrigger","registerPlugin","SplitText","cleanup","bp","Object","entries","add","breakpoints","context","tlName","tl","prepareTimeline","getScrollTrigger","scrollElement","tlInstance","push","name","animation","animations","animationInstance","createSingleAnimation","attributes","position","setupEventActions","handleResize","handlePageShow","handleLoad","refresh","forEach","elementData","element","targets","on","action","events","actionData","eventName","handler","handleAction","arguments","addEventListener","removeEventListener","actionName","actionTarget","actionArgs","warn","timelineEntry","find","update","getAll","trigger","debounce","passive","persisted","getConfig","key","scroll","keys","length","getSplitText","splittext","splitTextOptions","split","types","type","map","s","trim","animationTargets","includes","concat","chars","words","lines","keyframes","to","from","fromTo","ScrollSmoother","document","querySelector","create","wrapper","content","killAll","kill"],"mappings":"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"}