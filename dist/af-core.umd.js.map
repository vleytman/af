{"version":3,"file":"af-core.umd.js","sources":["../src/af-core.js"],"sourcesContent":["let Config = {\n  prefix: 'af-',\n  breakpoints: {\n    sm: '(max-width: 640px)',\n    md: '(min-width: 641px) and (max-width: 768px)',\n    lg: '(min-width: 769px) and (max-width: 1024px)',\n    xl: '(min-width: 1025px) and (max-width: 1280px)',\n    xxl: '(min-width: 1281px)',\n  },\n  engine: 'gsap',\n  debug: true,\n}\n\nlet AnimationEngine = {}\n\nconst debug = {\n  log: (...args) => { AF.Config.debug && console.log('[AF]', ...args) },\n  warn: (...args) => { AF.Config.debug && console.warn('[AF]', ...args) },\n  error: (...args) => { AF.Config.debug && console.error('[AF]', ...args) },\n}\n\nconst utils = {\n\n  deepMergeObjects (target, source) {\n    if (Array.isArray(target) && Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(source)) {\n      return source.slice()\n    } else if (Array.isArray(target)) {\n      return source\n    } else if (typeof target === 'object' && typeof source === 'object' && target !== null && source !== null) {\n      const output = { ...target }\n      Object.keys(source).forEach(key => {\n        output[key] = this.deepMergeObjects(target[key], source[key])\n      })\n      return output\n    } else {\n      return source\n    }\n  },\n\n  mergeConfig (config) {\n    AF.Config = this.deepMergeObjects(AF.Config, config)\n    AF.Config.breakpoints = config.breakpoints ?? AF.Config.breakpoints\n  },\n\n  hasElementsWithAttributes (elements, attributes) {\n    return elements.some(element => attributes.some(attr => Object.keys(element.attributes).includes(attr)))\n  },\n\n  generateRandomName () {\n    return Math.random().toString(36).substring(2, 10)\n  },\n\n  kebabCase (str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n  },\n\n  debounce (func, wait) {\n    let timeout\n    return function executedFunction (...args) {\n      const later = () => {\n        clearTimeout(timeout)\n        func(...args)\n      }\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n    }\n  },\n\n  getBreakpointMaxWidth (query) {\n    const maxWidthMatch = query.match(/\\(max-width:\\s*(\\d+)px\\)/)\n    const minWidthMatch = query.match(/\\(min-width:\\s*(\\d+)px\\)/)\n    if (maxWidthMatch) {\n      return parseInt(maxWidthMatch[1])\n    } else if (minWidthMatch) {\n      return Infinity\n    }\n    return 0\n  },\n\n}\n\nconst Parser = {\n\n  parsers: {\n    timeline: { flow: ['disallowEmpty', 'parseTimelineValue'], responsive: true },\n    from: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    to: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    keyframes: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues', 'parseKeyframesValue'], responsive: true },\n    options: { flow: ['disallowEmpty', 'parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    target: { flow: ['parseSelectorValue'], responsive: false },\n    on: { flow: ['disallowEmpty', 'parseOnValue'], responsive: true },\n    action: { flow: ['disallowEmpty', 'parseActionValue'], responsive: true },\n    scroll: { flow: ['parseObjectAttribute', 'parseJsonToObjectOrArray', 'normalizeAttributeValues'], responsive: true },\n    splittext: { flow: ['parseSplitTextValue'], responsive: true },\n    pause: { flow: ['parseEmptyValue'], responsive: true },\n  },\n\n  parseElements () {\n    const elements = Array.from(new Set([...this.getAnimatableElements(), ...this.getAnimatableElementsByPreset()]))\n    if (!elements) return\n    return this.processAttributes(elements)\n  },\n\n  getAnimatableElementsByPreset () {\n    if (!AF.Config.presets) return []\n    return Object.entries(AF.Config.presets).flatMap(([presetName, preset]) => {\n      const className = `${AF.Config.prefix}${utils.kebabCase(presetName)}`\n      return [...document.getElementsByClassName(className)].map(element => {\n        element.setAttribute(`${AF.Config.prefix}preset`, presetName)\n        return element\n      })\n    })\n  },\n\n  processAttributes (elements) {\n    if (!elements) return\n    let parsedElements = []\n    elements.forEach(element => {\n      try {\n        parsedElements.push(this.parseSingleElement(element))\n      } catch {\n        debug.error(`Can't parse element:`, element)\n        return parsedElements\n      }\n    })\n    parsedElements = this.propagateBreakpoints(parsedElements)\n    return parsedElements\n  },\n\n  parseSingleElement (element) {\n    const attributes = this.parseElementAttributes(element)\n    const targets = this.getTargets({ element, attributes })\n    return { element, attributes, targets }\n  },\n\n  propagateBreakpoints (data) {\n    const configBreakpoints = Object.keys(AF.Config.breakpoints).sort((a, b) => {\n      const aWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[a])\n      const bWidth = utils.getBreakpointMaxWidth(AF.Config.breakpoints[b])\n      return bWidth - aWidth\n    })\n    return data.map(element => {\n      for (const [attrKey, attrValue] of Object.entries(element.attributes)) {\n        if (this.parsers[attrKey] && this.parsers[attrKey].responsive) {\n          const hasDefault = 'default' in attrValue\n          const presentBreakpoints = Object.keys(attrValue).filter(bp => bp !== 'default' && bp in AF.Config.breakpoints)\n          let propagatedValues = {}\n          if (hasDefault) {\n            propagatedValues = utils.deepMergeObjects({}, attrValue.default)\n          }\n          configBreakpoints.forEach(bp => {\n            if (bp in attrValue) {\n              propagatedValues = utils.deepMergeObjects(propagatedValues, attrValue[bp])\n            }\n            element.attributes[attrKey][bp] = utils.deepMergeObjects({}, propagatedValues)\n          })\n          if (hasDefault) {\n            delete element.attributes[attrKey].default\n          }\n        }\n      }\n      return element\n    })\n  },\n\n  getTargets (elementData) {\n    if (elementData.attributes?.target === '&' || !elementData.attributes?.target) return [elementData.element]\n    const targetSelector = elementData.attributes.target.trim()\n    const subSelector = targetSelector.slice(1).trim()\n    if (targetSelector.startsWith('&')) {\n      const matchedElements = this.getMatchedElements(elementData.element, subSelector)\n      return matchedElements.length ? matchedElements : [elementData.element]\n    }\n    return document.querySelectorAll(targetSelector)\n  },\n\n  getMatchedElements (element, subSelector) {\n    if (subSelector.match(/^([.#\\[])/) && element.matches(subSelector)) return [element]\n    if (subSelector.startsWith('>')) return [...element.children].filter(child => child.matches(subSelector.slice(1).trim()))\n    return [...element.querySelectorAll(subSelector)]\n  },\n\n  getAnimatableElements () {\n    const elements = Array.from(document.querySelectorAll('*'))\n    return elements.filter(element =>\n      Array.from(element.attributes).some(attr => attr.name.startsWith(AF.Config.prefix))\n    )\n  },\n\n  parseElementAttributes (element) {\n    let parsedAttributes = {}\n    let presetName = null\n    Array.from(element.attributes).forEach(attr => {\n      if (attr.name === `${AF.Config.prefix}preset`) {\n        presetName = attr.value.trim()\n        return\n      }\n      if (attr.name.startsWith(AF.Config.prefix)) {\n        const components = this.extractAttributeComponents(attr.name)\n        if (!components) return\n        const { type, breakpoint } = components\n        if (!this.parsers[type]) {\n          debug.warn(`Unknown attribute: ${attr.name}`)\n          return\n        }\n        let parsedData = this.runParsers(element, type, attr.value)\n        if (parsedData) {\n          parsedAttributes[type] = parsedAttributes[type] ?? {}\n          parsedAttributes[type][breakpoint] = parsedData\n          parsedAttributes[type] = this.checkIfResponsiveAttribute(parsedAttributes[type], type)\n        } else {\n          debug.warn(`Error parsing \"${type}\" attribute value: ${attr.value}`)\n        }\n      }\n    })\n    if (presetName) {\n      const presetAttributes = this.parsePresetAttributes(presetName, element)\n      this.deepMergeAttributes(parsedAttributes, presetAttributes)\n    }\n    return parsedAttributes\n  },\n\n  extractAttributeComponents (attrName) {\n    const attrUnprefixedName = attrName.slice(AF.Config.prefix.length)\n    const match = attrUnprefixedName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/)\n    if (match[2] && !AF.Config.breakpoints[match[2]]) {\n      debug.warn(`Invalid breakpoint: ${match[2]}`)\n      return null\n    }\n    return match ? { type: match[1], breakpoint: match[2] || 'default' } : null\n  },\n\n  runParsers (element, type, value) {\n    try {\n      let parsedData = {}\n      let lastValue = null\n      for (const parser of this.parsers[type].flow) {\n        parsedData = lastValue ? this[parser](lastValue, element) : this[parser](value, element)\n        lastValue = parsedData\n      }\n      return parsedData\n    } catch (error) {\n      return null\n    }\n  },\n\n  disallowEmpty (value, element) {\n    if (value === '') throw new Error(`Empty value for attribute is not allowed`)\n    return value\n  },\n\n  checkIfResponsiveAttribute (data, type) {\n    return !Parser.parsers[type].responsive ? data[Object.keys(data)[0]] : data\n  },\n\n  parsePresetAttributes (presetName, element) {\n    const preset = AF.Config.presets[presetName]\n    if (!preset) {\n      debug.warn(`Preset \"${presetName}\" not found`)\n      return {}\n    }\n    return Object.entries(preset).reduce((presetAttrs, [attrName, attrValue]) => {\n      if (attrName === 'selector') return presetAttrs\n      const [, type, breakpoint = 'default'] = attrName.match(/^([a-zA-Z]+)(?:-([a-zA-Z0-9]+))?$/) || []\n      if (!type || !this.parsers[type]) {\n        debug.warn(`Invalid or unknown preset attribute: \"${attrName}\"`)\n        return presetAttrs\n      }\n      if (breakpoint !== 'default' && !AF.Config.breakpoints[breakpoint]) {\n        debug.warn(`Invalid breakpoint \"${breakpoint}\" in preset \"${presetName}\" for type \"${type}\"`)\n        return presetAttrs\n      }\n      let parsedData = this.runParsers(element, type, attrValue)\n      if (parsedData) {\n        presetAttrs[type] = { ...presetAttrs[type], [breakpoint]: parsedData }\n      } else {\n        debug.warn(`Error parsing \"${type}\" attribute value: ${attrValue}`)\n      }\n      return presetAttrs\n    }, {})\n  },\n\n  parseObjectAttribute (value, element) {\n    if (typeof value === 'object') return value // Already parsed\n    value = this.resolveVariables(value, element) // Resolve variables\n    value = this.escapeCommas(value) // Escape commas inside brackets\n    value = value.replace(/'/g, '\"') // Single quotes => double quotes\n      .replace(/\\s+/g, ' ').trim() // Normalize whitespace\n      .replace(/(^|[,{]\\s*)([^\\s,\"'{}[\\]:]+)(\\s*:)/g, '$1\"$2\"$3') // Quote keys (including at the start of the string)\n      .replace(/(:\\s*)([^,{}\\[\\]\\s][^,{}\\[\\]]*)(?=[,}\\]]|$)/g, (match, p1, p2) => { // Quote values, skipping arrays and objects\n        const trimmedValue = p2.trim()\n        if (trimmedValue.startsWith('[') || trimmedValue.startsWith('{')) return `${p1}${trimmedValue}` // Skip arrays and objects\n        if (/^-?\\d+(\\.\\d+)?$/.test(trimmedValue) || /^(true|false|null)$/i.test(trimmedValue)) return `${p1}${trimmedValue}` // Do not quote numbers, booleans, null\n        if (!/^\".*\"$/.test(trimmedValue)) return `${p1}\"${trimmedValue}\"` // Quote if not already quoted\n        return match\n      })\n      .replace(/__COMMA__/g, ',')\n\n    return value\n  },\n\n  escapeCommas (str) {\n    let result = ''\n    let depth = 0\n    let inQuote = false\n    let quoteChar = ''\n    const brackets = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    }\n    const stack = []\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i]\n\n      if (inQuote) {\n        result += c\n        if (c === quoteChar) {\n          inQuote = false\n        }\n      } else if (c === '\"' || c === '\\'') {\n        inQuote = true\n        quoteChar = c\n        result += c\n      } else if (brackets[c]) {\n        stack.push(brackets[c])\n        depth++\n        result += c\n      } else if (stack.length > 0 && c === stack[stack.length - 1]) {\n        stack.pop()\n        depth--\n        result += c\n      } else if (c === ',' && depth > 0) {\n        result += '__COMMA__'\n      } else {\n        result += c\n      }\n    }\n    return result\n  },\n\n  deepMergeAttributes (target, source) {\n    for (const [type, typeData] of Object.entries(source)) {\n      if (!target[type]) {\n        target[type] = utils.deepMergeObjects({}, typeData)\n        continue\n      }\n      for (const [breakpoint, value] of Object.entries(typeData)) {\n        if (!target[type][breakpoint]) {\n          target[type][breakpoint] = value\n        } else {\n          target[type][breakpoint] = utils.deepMergeObjects(target[type][breakpoint], value)\n        }\n      }\n    }\n  },\n\n  resolveVariables (str, element) {\n    let resolvedStr = str.replace(/var\\((--[^)]+)\\)/g, (match, varName) => {\n      const computedValue = getComputedStyle(element).getPropertyValue(varName).trim()\n      return computedValue || 'undefined'\n    })\n    resolvedStr = resolvedStr.replace(/\\${([^}]+)}/g, (_, p1) => this.evaluateExpression(p1.trim(), this.getElementContext(element)))\n    return resolvedStr\n  },\n\n  evaluateExpression: (() => {\n    const cache = new Map()\n    return (expression, context) => {\n      if (!cache.has(expression)) cache.set(expression, new Function('\"use strict\";return (' + expression + ')'))\n      try {\n        return cache.get(expression).call(context)\n      } catch (error) {\n        debug.error(`Error evaluating expression: ${expression}`, error)\n        return undefined\n      }\n    }\n  })(),\n\n  getElementContext (element) {\n    return {\n      $element: element,\n      window,\n      document,\n    }\n  },\n\n  parseJsonToObjectOrArray (value, element) {\n    if (typeof value === 'object') return value\n    try {\n      return JSON.parse(`{${value}}`)\n    } catch (error1) {\n      try {\n        return JSON.parse(`[${value}]`)\n      } catch (error2) {\n        debug.error('Error parsing attribute value:', value, error2)\n        return null\n      }\n    }\n  },\n\n  normalizeAttributeValues (data, depth = 0, maxDepth = 100) {\n    if (depth > maxDepth) {\n      AF.debug.error('Maximum recursion depth exceeded in normalizeAttributeValues')\n      return data\n    }\n    if (Array.isArray(data)) {\n      return data.map(value => this.normalizeAttributeValues(value, depth + 1, maxDepth))\n    }\n    if (data !== null && typeof data === 'object') {\n      return Object.fromEntries(\n        Object.entries(data).map(([key, value]) => [key, this.normalizeAttributeValues(value, depth + 1, maxDepth)])\n      )\n    }\n    return this.normalizeValue(data)\n  },\n\n  normalizeValue (value) {\n    if (typeof value === 'number') return value\n    if (typeof value !== 'string') return value\n    const trimmed = value.trim()\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) return Number(trimmed)\n    if (/^(true|false)$/i.test(trimmed)) return trimmed.toLowerCase() === 'true'\n    return value\n  },\n\n  parseTimelineValue (value) {\n    const parts = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (parts.length > 3) throw new Error(`Invalid timeline value: ${value}. Expected format: name[, position][, properties]`)\n    return parts.length === 1 ? { name: String(parts[0]), position: null } : parts.length === 2 ? { name: parts[0], position: this.normalizeValue(parts[1]) } : {\n      name: parts[0],\n      position: this.normalizeValue(parts[1]),\n      options: this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(parts[2], null), null))[0]\n    }\n  },\n\n  parseSelectorValue (value, element) {\n    return value.trim()\n  },\n\n  parseOnValue (value, element) {\n    const parts = value.split(',').map(s => s.trim())\n    return { events: parts }\n  },\n\n  parseActionValue (value, element) {\n    const [action, target, ...argParts] = value.split(/,(?![^{}]*})/).map(s => s.trim())\n    if (!target || !action) {\n      throw new Error(`Invalid action format: \"${value}\", needs at least target and action.`)\n    }\n    const argStr = argParts.join(',').trim()\n    const args = argStr ? argStr.startsWith('{') && argStr.endsWith('}')\n      ? this.normalizeAttributeValues(this.parseJsonToObjectOrArray(this.parseObjectAttribute(argStr, element), element))\n      : this.normalizeValue(argStr) : {}\n    return {\n      action, target,\n      arguments: args\n    }\n  },\n\n  parseKeyframesValue (value, element) {\n    return value\n  },\n\n  parseSplitTextValue (value, element) {\n    if (typeof value === 'object') return value\n    if (value.includes(':')) {\n      value = this.parseObjectAttribute(value, element)\n      value = this.parseJsonToObjectOrArray(value, element)\n      value = this.normalizeAttributeValues(value)\n      return value\n    }\n    const types = value.split(',').map(s => s.trim()).filter(s => s.length > 0)\n    return { type: types.join(', ') }\n  },\n\n  parseEmptyValue (value, element) {\n    return true\n  },\n\n  getTimelines (elements) {\n    const timelines = {}\n    const processBreakpoint = (item, bp) => {\n      const { attributes, element, targets } = item\n      const timelineName = attributes.timeline?.[bp]?.name ?? attributes.timeline?.default?.name ?? (element.id.length ? element.id : null) ?? utils.generateRandomName()\n      timelines[bp] ??= {}\n      timelines[bp][timelineName] ??= { animations: [], options: {} }\n      const bpAttrs = Object.fromEntries(\n        Object.entries(attributes)\n          .filter(([, value]) => value[bp] || (value.default && bp === 'default'))\n          .map(([key, value]) => [key, value[bp] ?? value.default])\n      )\n      timelines[bp][timelineName].animations.push({ element, attributes: bpAttrs, targets })\n      if (Object.keys(timelines[bp][timelineName].options).length === 0) {\n        timelines[bp][timelineName].options = this.getTimelineOptions(attributes.timeline)\n      }\n    }\n    elements.forEach(item => {\n      const usedBreakpoints = new Set(Object.values(item.attributes).flatMap(attr => Object.keys(attr)))\n      if (usedBreakpoints.has('default')) {\n        usedBreakpoints.delete('default')\n        processBreakpoint(item, 'default')\n      }\n      usedBreakpoints.forEach(bp => processBreakpoint(item, bp))\n    })\n    return Object.fromEntries(Object.entries(timelines).filter(([key]) => isNaN(key)))\n  },\n\n  getTimelineOptions (timeline) {\n    if (!timeline) return {}\n    for (const key in timeline) {\n      if (timeline[key] && timeline[key].options) return timeline[key].options\n    }\n    return {}\n  },\n\n}\n\nconst AF = {\n\n  debug,\n  utils,\n  Parser,\n  Config,\n  engines: {},\n\n  registerEngine (name, engineClass, plugins) {\n    AF.engines[name] = {}\n    AF.engines[name].engineClass = engineClass\n    AF.engines[name].plugins = plugins\n  },\n\n  init (config = null) {\n    if (!AF.engines) return\n    if (config) AF.utils.mergeConfig(config)\n    const elements = Parser.parseElements()\n    const timelines = Parser.getTimelines(elements)\n    const EngineClass = AF.engines[Config.engine].engineClass\n    if (!EngineClass) {\n      this.debug.error(`Incorrect animation engine: ${AF.Config.engine}`)\n      return\n    }\n    const animationEngine = new EngineClass(elements, timelines)\n    if (animationEngine.init && typeof animationEngine.init === 'function') {\n      animationEngine.init(AF.engines[Config.engine], AF.Config)\n    }\n  },\n\n}\n\nexport default AF"],"names":["Config","prefix","breakpoints","sm","md","lg","xl","xxl","engine","debug","log","args","AF","console","warn","error","utils","deepMergeObjects","target","source","Array","isArray","slice","output","Object","keys","forEach","key","this","mergeConfig","config","hasElementsWithAttributes","elements","attributes","some","element","attr","includes","generateRandomName","Math","random","toString","substring","kebabCase","str","replace","toLowerCase","debounce","func","wait","timeout","clearTimeout","setTimeout","getBreakpointMaxWidth","query","maxWidthMatch","match","minWidthMatch","parseInt","Infinity","Parser","parsers","timeline","flow","responsive","from","to","keyframes","options","on","action","scroll","splittext","pause","parseElements","Set","getAnimatableElements","getAnimatableElementsByPreset","processAttributes","presets","entries","flatMap","presetName","preset","className","document","getElementsByClassName","map","setAttribute","parsedElements","push","parseSingleElement","propagateBreakpoints","parseElementAttributes","targets","getTargets","data","configBreakpoints","sort","a","b","aWidth","attrKey","attrValue","hasDefault","filter","bp","propagatedValues","default","elementData","targetSelector","trim","subSelector","startsWith","matchedElements","getMatchedElements","length","querySelectorAll","matches","children","child","name","parsedAttributes","components","extractAttributeComponents","type","breakpoint","parsedData","runParsers","value","checkIfResponsiveAttribute","presetAttributes","parsePresetAttributes","deepMergeAttributes","attrName","lastValue","parser","disallowEmpty","Error","reduce","presetAttrs","parseObjectAttribute","resolveVariables","escapeCommas","p1","p2","trimmedValue","test","result","depth","inQuote","quoteChar","brackets","stack","i","c","pop","typeData","resolvedStr","varName","getComputedStyle","getPropertyValue","_","evaluateExpression","getElementContext","cache","Map","expression","context","has","set","Function","get","call","$element","window","parseJsonToObjectOrArray","JSON","parse","error1","error2","normalizeAttributeValues","maxDepth","fromEntries","normalizeValue","trimmed","Number","parseTimelineValue","parts","split","s","String","position","parseSelectorValue","parseOnValue","events","parseActionValue","argParts","argStr","join","arguments","endsWith","parseKeyframesValue","parseSplitTextValue","parseEmptyValue","getTimelines","timelines","processBreakpoint","item","timelineName","id","animations","bpAttrs","getTimelineOptions","usedBreakpoints","values","delete","isNaN","engines","registerEngine","engineClass","plugins","init","EngineClass","animationEngine"],"mappings":"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"}